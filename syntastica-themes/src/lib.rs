#![doc = include_str!("../README.md")]
#![cfg_attr(
    feature = "docs",
    cfg_attr(doc, doc = ::document_features::document_features!(feature_label = r#"<span class="stab portability"><code>{feature}</code></span>"#))
)]
#![cfg_attr(all(doc, CHANNEL_NIGHTLY), feature(doc_auto_cfg))]
#![warn(rust_2018_idioms)]
// #![deny(missing_docs)]

use syntastica_core::theme::ResolvedTheme;

pub mod gruvbox;
pub mod one;

/////////////////////////////////////////////
//// All following code is autogenerated ////
//// by running `cargo xtask codegen` in ////
//// the syntastica workspace. //////////////
/////////////////////////////////////////////

/// Try to get a theme given its path as a string.
///
/// For a list of all acceptable theme names see [`THEMES`].
///
/// # Example
///
/// ```
/// assert_eq!(
///     syntastica_themes::from_str("one::dark"),
///     Some(syntastica_themes::one::dark()),
/// );
/// ```
pub fn from_str(theme_name: impl AsRef<str>) -> Option<ResolvedTheme> {
    match theme_name.as_ref() {
        "gruvbox::dark" => Some(gruvbox::dark()),
        "gruvbox::light" => Some(gruvbox::light()),
        "one::cool" => Some(one::cool()),
        "one::dark" => Some(one::dark()),
        "one::darker" => Some(one::darker()),
        "one::deep" => Some(one::deep()),
        "one::light" => Some(one::light()),
        "one::warm" => Some(one::warm()),
        "one::warmer" => Some(one::warmer()),
        _ => None,
    }
}

/// A list of all theme names as they are accepted by [`from_str`].
pub const THEMES: &[&str] = &[
    "gruvbox::dark",
    "gruvbox::light",
    "one::cool",
    "one::dark",
    "one::darker",
    "one::deep",
    "one::light",
    "one::warm",
    "one::warmer",
];
