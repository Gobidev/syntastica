//! This crate defines constants for three types of tree-sitter queries for lots of parsers.
//! It is intended to be used via [syntastica](https://crates.io/crates/syntastica).
//!
//! The three types of queries are:
//!
//! 1. `highlights`: defining the highlight captures for nodes
//! 2. `injections`: defining where other languages are injected for highlighting
//! 3. `locals`: keeping track of scopes, variables, parameters, etc. to have occurrences of those
//!    be highlighted the same everywhere
//!
//! The constants are defined as `<language_name>_<kind>` where `<kind>` is one of `HIGHLIGHTS`,
//! `INJECTIONS`, or `LOCALS`. The `INJECTIONS` and `LOCALS` may be empty for some languages.
//!
//! The source `lib.rs` file is automatically generated with `cargo xtask codegen` inside the
//! syntastica workspace.
#![cfg_attr(all(doc, CHANNEL_NIGHTLY), feature(doc_auto_cfg))]
#![cfg_attr(rustfmt, rustfmt_skip)]

pub const ASM_HIGHLIGHTS: &str = "[\",\" \":\"] @punctuation.delimiter\n[\"(\" \")\" \"[\" \"]\"]  @punctuation.bracket\n\n[\"+\" \"-\" \"*\"] @operator\n\n[\n  \"byte\"\n  \"word\"\n  \"dword\"\n  \"qword\"\n  \"ptr\"\n  \"rel\"\n] @keyword\n\n; Operators & Punctuation\n(string) @string\n\n; Keywords\n(int) @number\n(line_comment) @comment @spell\n\n; Literals\n(instruction\n  kind: (_) @function.call)\n\n; Comments\n(meta\n  kind: (_) @function.builtin)\n(reg) @variable.builtin\n(label (ident) @label)\n";
pub const ASM_INJECTIONS: &str = "";
pub const ASM_LOCALS: &str = "";

pub const BASH_HIGHLIGHTS: &str = "((program . (comment) @preproc)\n  (#match? @preproc \"^#!/\" ))\n(regex) @string.regex\n\n(case_item\n  value: (word) @parameter)\n\n((variable_name) @constant\n (#match? @constant \"^[A-Z][A-Z_0-9]*$\" ))\n\n(variable_name) @variable\n\n(expansion\n  [ \"${\" \"}\" ] @punctuation.bracket)\n\n(file_redirect\n  descriptor: (file_descriptor) @operator\n  destination: (word) @parameter)\n\n((word) @number\n  (#match? @number \"^[0-9]+$\" ))\n\n(command\n  argument: [\n             (word) @parameter\n             (concatenation (word) @parameter)\n             ])\n\n((command_name (word) @function.builtin)\n (#match? @function.builtin \"^(alias|cd|clear|echo|eval|exit|getopts|popd|pushd|return|set|shift|shopt|source|test)$\" ))\n\n(command_name (word) @function.call)\n\n(function_definition\n  name: (word) @function)\n\n(process_substitution\n  [ \"<(\" \")\" ] @punctuation.bracket)\n\n\n(command_substitution\n  [ \"$(\" \")\" ] @punctuation.bracket)\n\n(test_operator) @string\n\n(comment) @comment @spell\n((word) @boolean\n  (#match? @boolean \"^(true|false)$\" ))\n\n((word) @constant.builtin\n (#match? @constant.builtin \"^SIG(HUP|INT|QUIT|ILL|TRAP|ABRT|BUS|FPE|KILL|USR[12]|SEGV|PIPE|ALRM|TERM|STKFLT|CHLD|CONT|STOP|TSTP|TT(IN|OU)|URG|XCPU|XFSZ|VTALRM|PROF|WINCH|IO|PWR|SYS|RTMIN([+]([1-9]|1[0-5]))?|RTMAX(-([1-9]|1[0-4]))?)$\"))\n\n(special_variable_name) @constant\n\n; trap -l\n\"function\" @keyword.function\n\n[\n \"declare\"\n \"export\"\n \"local\"\n \"readonly\"\n \"unset\"\n ] @keyword\n\n[\n \"for\"\n \"do\"\n \"done\"\n \"while\"\n ] @repeat\n\n[\n \"if\"\n \"then\"\n \"else\"\n \"elif\"\n \"fi\"\n \"case\"\n \"in\"\n \"esac\"\n ] @conditional\n\n(variable_assignment (word) @string)\n\n[\n (string)\n (raw_string)\n (ansi_c_string)\n (heredoc_body)\n] @string @spell\n\n[\n \">\"\n \">>\"\n \"<\"\n \"<<\"\n \"&\"\n \"&&\"\n \"|\"\n \"||\"\n \"=\"\n \"=~\"\n \"==\"\n \"!=\"\n ] @operator\n\n[\n \"$\"\n] @punctuation.special\n\n[\n \";\"\n \";;\"\n (heredoc_start)\n ] @punctuation.delimiter\n\n[\n \"(\"\n \")\"\n \"((\"\n \"))\"\n \"{\"\n \"}\"\n \"[\"\n \"]\"\n \"[[\"\n \"]]\"\n ] @punctuation.bracket\n\n(expansion\n  \"${\" @punctuation.special\n  \"}\" @punctuation.special) @none\n(simple_expansion) @none\n";
pub const BASH_INJECTIONS: &str = ";; Forked from https://github.com/helix-editor/helix\n;; Licensed under the Mozilla Public License 2.0\n\n((comment) @injection.content\n (#set! injection.language \"comment\"))\n\n((regex) @injection.content\n (#set! injection.language \"regex\"))\n\n(command\n  name: (command_name (word) @_command)\n  argument: (raw_string) @injection.content\n (#match? @_command \"^[gnm]?awk$\")\n (#set! injection.language \"awk\"))\n";
pub const BASH_LOCALS: &str = ";; Forked from https://github.com/nvim-treesitter/nvim-treesitter/blob/master/queries/bash/locals.scm\n;; Licensed under the Apache License 2.0\n\n; Scopes\n(function_definition) @local.scope\n\n; Definitions\n(variable_assignment\n  name: (variable_name) @local.definition)\n\n(function_definition\n  name: (word) @local.definition)\n\n; References\n(variable_name) @local.reference\n(word) @local.reference\n";

pub const C_HIGHLIGHTS: &str = "(ERROR) @error\n[\n  \"__attribute__\"\n  \"__cdecl\"\n  \"__clrcall\"\n  \"__stdcall\"\n  \"__fastcall\"\n  \"__thiscall\"\n  \"__vectorcall\"\n  \"_unaligned\"\n  \"__unaligned\"\n  \"__declspec\"\n  (attribute_declaration)\n] @attribute\n\n(preproc_params (identifier) @parameter)\n\n(parameter_declaration\n  declarator: (pointer_declarator) @parameter)\n\n(parameter_declaration\n  declarator: (identifier) @parameter)\n\n((comment) @comment.documentation\n  (#match? @comment.documentation \"^/[*][*][^*].*[*]/$\" ))\n\n;; Parameters\n(comment) @comment @spell\n\n(preproc_function_def\n  name: (identifier) @function.macro)\n\n(function_declarator\n  declarator: (identifier) @function)\n(call_expression\n  function: (field_expression\n    field: (field_identifier) @function.call))\n(call_expression\n  function: (identifier) @function.call)\n(preproc_call\n  directive: (preproc_directive) @_u\n  argument: (_) @constant\n  (#eq? @_u \"#undef\"))\n\n(preproc_def\n  name: (_) @constant)\n((identifier) @constant.builtin\n    (#match? @constant.builtin \"^(stderr|stdin|stdout)$\" ))\n\n;; Preproc def / undef\n(case_statement\n  value: (identifier) @constant)\n\n(enumerator\n  name: (identifier) @constant)\n((identifier) @constant\n (#match? @constant \"^[A-Z][A-Z0-9_]+$\" ))\n(primitive_type) @type.builtin\n\n(type_definition\n  declarator: (type_identifier) @type.definition)\n\n(linkage_specification\n  \"extern\" @storageclass)\n\n(type_qualifier) @type.qualifier\n\n(storage_class_specifier) @storageclass\n\n[\n (type_identifier)\n (sized_type_specifier)\n (type_descriptor)\n] @type\n\n(statement_identifier) @label\n\n(((field_identifier) @property)\n (#has-ancestor? @property field_declaration)\n (#not-has-ancestor? @property function_declarator))\n\n(field_designator) @property\n(((field_expression\n     (field_identifier) @property)) @_parent\n (#not-has-parent? @_parent template_method function_declarator call_expression))\n\n[\n (preproc_arg)\n (preproc_defined)\n]  @function.macro\n\n(char_literal) @character\n\n(number_literal) @number\n(null) @constant.builtin\n(escape_sequence) @string.escape\n\n(system_lib_string) @string\n(string_literal) @string\n(conditional_expression [ \"?\" \":\" ] @conditional.ternary)\n\n[\n (true)\n (false)\n] @boolean\n\n(comma_expression [ \",\" ] @operator)\n\n[\n  \"=\"\n\n  \"-\"\n  \"*\"\n  \"/\"\n  \"+\"\n  \"%\"\n\n  \"~\"\n  \"|\"\n  \"&\"\n  \"^\"\n  \"<<\"\n  \">>\"\n\n  \"->\"\n  \".\"\n\n  \"<\"\n  \"<=\"\n  \">=\"\n  \">\"\n  \"==\"\n  \"!=\"\n\n  \"!\"\n  \"&&\"\n  \"||\"\n\n  \"-=\"\n  \"+=\"\n  \"*=\"\n  \"/=\"\n  \"%=\"\n  \"|=\"\n  \"&=\"\n  \"^=\"\n  \">>=\"\n  \"<<=\"\n  \"--\"\n  \"++\"\n] @operator\n\n;; Make sure the comma operator is given a highlight group after the comma\n;; punctuator so the operator is highlighted properly.\n[ \"(\" \")\" \"[\" \"]\" \"{\" \"}\"] @punctuation.bracket\n\n\"...\" @punctuation.special\n\n[ \";\" \":\" \",\" ] @punctuation.delimiter\n\n\"#include\" @include\n\n\"#define\" @define\n\n[\n  \"#if\"\n  \"#ifdef\"\n  \"#ifndef\"\n  \"#else\"\n  \"#elif\"\n  \"#endif\"\n  (preproc_directive)\n] @preproc\n\n[\n \"if\"\n \"else\"\n \"case\"\n \"switch\"\n] @conditional\n\n[\n  \"while\"\n  \"for\"\n  \"do\"\n  \"continue\"\n  \"break\"\n] @repeat\n\n\"return\" @keyword.return\n\n\"sizeof\" @keyword.operator\n\n[\n  \"default\"\n  \"enum\"\n  \"struct\"\n  \"typedef\"\n  \"union\"\n  \"goto\"\n] @keyword\n\n(identifier) @variable\n\n";
pub const C_INJECTIONS: &str = "((comment) @injection.content\n (#set! injection.language \"comment\"))\n\n((preproc_arg) @injection.content\n (#set! injection.language \"c\"))\n";
pub const C_LOCALS: &str = "";

pub const CPP_HIGHLIGHTS: &str = "(literal_suffix) @operator\n(template_argument_list\n  [\"<\" \">\"] @punctuation.bracket)\n\n\"::\" @punctuation.delimiter\n\n\"<=>\" @operator\n\n[\n \"new\"\n \"delete\"\n\n \"xor\"\n \"bitand\"\n \"bitor\"\n \"compl\"\n \"not\"\n \"xor_eq\"\n \"and_eq\"\n \"or_eq\"\n \"not_eq\"\n \"and\"\n \"or\"\n] @keyword.operator\n\n[\n \"public\"\n \"private\"\n \"protected\"\n \"virtual\"\n \"final\"\n] @type.qualifier\n\n[\n \"co_yield\"\n \"co_return\"\n] @keyword.coroutine.return\n\n[\n  \"co_await\"\n] @keyword.coroutine\n\n[\n \"class\"\n \"decltype\"\n \"explicit\"\n \"friend\"\n \"namespace\"\n \"override\"\n \"template\"\n \"typename\"\n \"using\"\n \"concept\"\n \"requires\"\n] @keyword\n\n[\n \"try\"\n \"catch\"\n \"noexcept\"\n \"throw\"\n] @exception\n\n\n(raw_string_literal)  @string\n\n; Keywords\n\n(false) @boolean\n\n; Literals\n\n(true) @boolean\n(nullptr) @constant.builtin\n\n(this) @variable.builtin\n((field_initializer\n  (field_identifier) @constructor\n  (argument_list))\n (#match? @constructor \"^[A-Z]\" ))\n\n\n; Constants\n\n((call_expression\n  function: (field_expression\n              field: (field_identifier) @constructor))\n(#match? @constructor \"^[A-Z]\" ))\n\n;; constructing a type in an initializer list: Constructor ():  **SuperType (1)**\n((call_expression\n  function: (qualified_identifier\n              name: (identifier) @constructor))\n(#match? @constructor \"^[A-Z]\" ))\n\n((call_expression\n  function: (identifier) @constructor)\n(#match? @constructor \"^[A-Z]\" ))\n((function_declarator\n  (qualified_identifier\n    (identifier) @constructor))\n  (#match? @constructor \"^[A-Z]\" ))\n\n(call_expression\n  (field_expression\n    (field_identifier) @method.call))\n\n; constructors\n\n(function_declarator\n  (template_method\n    (field_identifier) @method))\n((qualified_identifier\n  (qualified_identifier\n    (qualified_identifier\n      (qualified_identifier\n        (template_function\n          (identifier) @function.call))))) @_parent\n  (#has-ancestor? @_parent call_expression))\n\n; methods\n(call_expression\n  (qualified_identifier\n    (qualified_identifier\n      (qualified_identifier\n        (template_function\n          (identifier) @function.call)))))\n(call_expression\n  (qualified_identifier\n    (qualified_identifier\n      (template_function\n        (identifier) @function.call))))\n(call_expression\n  (qualified_identifier\n    (template_function\n      (identifier) @function.call)))\n(call_expression\n  (template_function\n    (identifier) @function.call))\n((qualified_identifier\n  (qualified_identifier\n    (qualified_identifier\n      (qualified_identifier\n        (identifier) @function.call)))) @_parent\n  (#has-ancestor? @_parent call_expression))\n\n(call_expression\n  (qualified_identifier\n    (qualified_identifier\n      (qualified_identifier\n        (identifier) @function.call))))\n(call_expression\n  (qualified_identifier\n    (qualified_identifier\n      (identifier) @function.call)))\n(call_expression\n  (qualified_identifier\n    (identifier) @function.call))\n\"static_assert\" @function.builtin\n\n\"operator\" @function\n(operator_name) @function\n(function_declarator\n  (template_function\n    (identifier) @function))\n\n((qualified_identifier\n  (qualified_identifier\n    (qualified_identifier\n      (qualified_identifier\n        (identifier) @function)))) @_parent\n  (#has-ancestor? @_parent function_declarator))\n\n(function_declarator\n  (qualified_identifier\n    (qualified_identifier\n      (qualified_identifier\n        (identifier) @function))))\n(function_declarator\n  (qualified_identifier\n    (qualified_identifier\n      (identifier) @function)))\n(function_declarator\n  (qualified_identifier\n    (identifier) @function))\n(destructor_name\n  (identifier) @method)\n\n; functions\n(using_declaration . \"using\" . \"namespace\" . [(qualified_identifier) (identifier)] @namespace)\n\n(case_statement\n  value: (qualified_identifier (identifier) @constant))\n\n((namespace_identifier) @type\n                        (#match? @type \"^[A-Z]\" ))\n\n(namespace_identifier) @namespace\n(auto) @type.builtin\n\n(alias_declaration\n  name: (type_identifier) @type.definition)\n\n(concept_definition\n  name: (identifier) @type.definition)\n\n(function_declarator\n  declarator: (field_identifier) @method)\n\n(field_initializer\n (field_identifier) @property)\n\n(field_declaration\n  (field_identifier) @field)\n\n(((field_expression\n     (field_identifier) @method)) @_parent\n (#has-parent? @_parent template_method function_declarator))\n\n(optional_parameter_declaration\n    declarator: (_) @parameter)\n\n;(field_expression) @parameter ;; How to highlight this?\n\n(variadic_parameter_declaration\n  declarator: (variadic_declarator\n                (_) @parameter))\n; int foo = 0\n(parameter_declaration\n  declarator: (reference_declarator) @parameter)\n\n; function(Foo ...foo)\n((identifier) @field\n (#match? @field \"(^_|^m_|_$)\"))\n\n(ERROR) @error\n\n[\n  \"__attribute__\"\n  \"__cdecl\"\n  \"__clrcall\"\n  \"__stdcall\"\n  \"__fastcall\"\n  \"__thiscall\"\n  \"__vectorcall\"\n  \"_unaligned\"\n  \"__unaligned\"\n  \"__declspec\"\n  (attribute_declaration)\n] @attribute\n\n(preproc_params (identifier) @parameter)\n\n(parameter_declaration\n  declarator: (pointer_declarator) @parameter)\n\n(parameter_declaration\n  declarator: (identifier) @parameter)\n\n((comment) @comment.documentation\n  (#match? @comment.documentation \"^/[*][*][^*].*[*]/$\" ))\n\n;; Parameters\n(comment) @comment @spell\n\n(preproc_function_def\n  name: (identifier) @function.macro)\n\n(function_declarator\n  declarator: (identifier) @function)\n(call_expression\n  function: (field_expression\n    field: (field_identifier) @function.call))\n(call_expression\n  function: (identifier) @function.call)\n(preproc_call\n  directive: (preproc_directive) @_u\n  argument: (_) @constant\n  (#eq? @_u \"#undef\"))\n\n(preproc_def\n  name: (_) @constant)\n((identifier) @constant.builtin\n    (#match? @constant.builtin \"^(stderr|stdin|stdout)$\" ))\n\n;; Preproc def / undef\n(case_statement\n  value: (identifier) @constant)\n\n(enumerator\n  name: (identifier) @constant)\n((identifier) @constant\n (#match? @constant \"^[A-Z][A-Z0-9_]+$\" ))\n(primitive_type) @type.builtin\n\n(type_definition\n  declarator: (type_identifier) @type.definition)\n\n(linkage_specification\n  \"extern\" @storageclass)\n\n(type_qualifier) @type.qualifier\n\n(storage_class_specifier) @storageclass\n\n[\n (type_identifier)\n (sized_type_specifier)\n (type_descriptor)\n] @type\n\n(statement_identifier) @label\n\n(((field_identifier) @property)\n (#has-ancestor? @property field_declaration)\n (#not-has-ancestor? @property function_declarator))\n\n(field_designator) @property\n(((field_expression\n     (field_identifier) @property)) @_parent\n (#not-has-parent? @_parent template_method function_declarator call_expression))\n\n[\n (preproc_arg)\n (preproc_defined)\n]  @function.macro\n\n(char_literal) @character\n\n(number_literal) @number\n(null) @constant.builtin\n(escape_sequence) @string.escape\n\n(system_lib_string) @string\n(string_literal) @string\n(conditional_expression [ \"?\" \":\" ] @conditional.ternary)\n\n[\n (true)\n (false)\n] @boolean\n\n(comma_expression [ \",\" ] @operator)\n\n[\n  \"=\"\n\n  \"-\"\n  \"*\"\n  \"/\"\n  \"+\"\n  \"%\"\n\n  \"~\"\n  \"|\"\n  \"&\"\n  \"^\"\n  \"<<\"\n  \">>\"\n\n  \"->\"\n  \".\"\n\n  \"<\"\n  \"<=\"\n  \">=\"\n  \">\"\n  \"==\"\n  \"!=\"\n\n  \"!\"\n  \"&&\"\n  \"||\"\n\n  \"-=\"\n  \"+=\"\n  \"*=\"\n  \"/=\"\n  \"%=\"\n  \"|=\"\n  \"&=\"\n  \"^=\"\n  \">>=\"\n  \"<<=\"\n  \"--\"\n  \"++\"\n] @operator\n\n;; Make sure the comma operator is given a highlight group after the comma\n;; punctuator so the operator is highlighted properly.\n[ \"(\" \")\" \"[\" \"]\" \"{\" \"}\"] @punctuation.bracket\n\n\"...\" @punctuation.special\n\n[ \";\" \":\" \",\" ] @punctuation.delimiter\n\n\"#include\" @include\n\n\"#define\" @define\n\n[\n  \"#if\"\n  \"#ifdef\"\n  \"#ifndef\"\n  \"#else\"\n  \"#elif\"\n  \"#endif\"\n  (preproc_directive)\n] @preproc\n\n[\n \"if\"\n \"else\"\n \"case\"\n \"switch\"\n] @conditional\n\n[\n  \"while\"\n  \"for\"\n  \"do\"\n  \"continue\"\n  \"break\"\n] @repeat\n\n\"return\" @keyword.return\n\n\"sizeof\" @keyword.operator\n\n[\n  \"default\"\n  \"enum\"\n  \"struct\"\n  \"typedef\"\n  \"union\"\n  \"goto\"\n] @keyword\n\n(identifier) @variable\n\n";
pub const CPP_INJECTIONS: &str = "\n((comment) @injection.content\n (#set! injection.language \"comment\"))\n\n((preproc_arg) @injection.content\n (#set! injection.language \"c\"))\n\n(raw_string_literal\n  delimiter: (raw_string_delimiter) @injection.language\n  (raw_string_content) @injection.content)\n";
pub const CPP_LOCALS: &str = "";

pub const CSS_HIGHLIGHTS: &str = "(ERROR) @error\n[\n \"{\"\n \")\"\n \"(\"\n \"}\"\n ] @punctuation.bracket\n\n[\n \"#\"\n \",\"\n \".\"\n \":\"\n \"::\"\n \";\"\n ] @punctuation.delimiter\n\n[\n (integer_value)\n (float_value)\n ] @number\n\n[\n (string_value)\n (color_value)\n (unit)\n ] @string\n\n((plain_value) @type\n               (#match? @type \"^--\"))\n\n((property_name) @type.definition\n                 (#match? @type.definition \"^--\"))\n(namespace_name) @namespace\n\n[\n (class_name)\n (id_name)\n (property_name)\n (feature_name)\n (attribute_name)\n ] @property\n\n(pseudo_class_selector (class_name) @property)\n\n(pseudo_element_selector \"::\" (tag_name) @property)\n(attribute_selector (plain_value) @string)\n(important) @type.qualifier\n\n[\n \"~\"\n \">\"\n \"+\"\n \"-\"\n \"*\"\n \"/\"\n \"=\"\n \"^=\"\n \"|=\"\n \"~=\"\n \"$=\"\n \"*=\"\n \"and\"\n \"or\"\n \"not\"\n \"only\"\n ] @operator\n\n(function_name) @function\n\n[\n (tag_name)\n (nesting_selector)\n (universal_selector)\n ] @type\n\n(comment) @comment @spell\n\n\"@import\" @include\n\n[\n \"@media\"\n \"@charset\"\n \"@namespace\"\n \"@supports\"\n \"@keyframes\"\n (at_keyword)\n (to)\n (from)\n ] @keyword\n\n";
pub const CSS_INJECTIONS: &str = "((comment) @injection.content\n (#set! injection.language \"comment\"))\n";
pub const CSS_LOCALS: &str = "";

pub const GO_HIGHLIGHTS: &str = "((interpreted_string_literal) @spell\n  (#not-has-parent? @spell import_spec))\n(ERROR) @error\n\n; Spell\n\n(source_file\n  (comment)+ @comment.documentation\n  . (var_declaration))\n\n; Errors\n\n(source_file\n  (comment)+ @comment.documentation\n  . (type_declaration))\n\n(source_file\n  (comment)+ @comment.documentation\n  . (function_declaration))\n\n(source_file\n  (comment)+ @comment.documentation\n  . (const_declaration))\n\n(source_file . (comment)+ @comment.documentation)\n\n(comment) @comment @spell\n\n;; Doc Comments\n\n(field_declaration name: (field_identifier) @field)\n\n; Comments\n\n(keyed_element\n  . (literal_element (identifier) @field))\n(nil) @constant.builtin\n\n[\n (true)\n (false)\n] @boolean\n\n(imaginary_literal) @number\n\n(float_literal) @float\n(int_literal) @number\n(escape_sequence) @string.escape\n\n(rune_literal) @string\n(raw_string_literal) @string @spell\n(interpreted_string_literal) @string\n\"]\" @punctuation.bracket\n\n\n; Literals\n\n\"[\" @punctuation.bracket\n\"}\" @punctuation.bracket\n\"{\" @punctuation.bracket\n\")\" @punctuation.bracket\n\"(\" @punctuation.bracket\n\";\" @punctuation.delimiter\n\n\":\" @punctuation.delimiter\n\",\" @punctuation.delimiter\n\".\" @punctuation.delimiter\n((identifier) @function.builtin\n (#match? @function.builtin \"^(append|cap|close|complex|copy|delete|imag|len|make|new|panic|print|println|real|recover)$\" ))\n\n\n; Delimiters\n\n((type_identifier) @type.builtin\n (#match? @type.builtin \"^(any|bool|byte|complex128|complex64|error|float32|float64|int|int16|int32|int64|int8|rune|string|uint|uint16|uint32|uint64|uint8|uintptr)$\" ))\n\n\n;; Builtin functions\n\n[\n  \"else\"\n  \"case\"\n  \"switch\"\n  \"if\"\n ] @conditional\n\n\n;; Builtin types\n\n[\n  \"import\"\n  \"package\"\n] @include\n\n\"for\" @repeat\n\n\"return\" @keyword.return\n\n\"func\" @keyword.function\n[\n  \"break\"\n  \"chan\"\n  \"const\"\n  \"continue\"\n  \"default\"\n  \"defer\"\n  \"go\"\n  \"goto\"\n  \"interface\"\n  \"map\"\n  \"range\"\n  \"select\"\n  \"struct\"\n  \"type\"\n  \"var\"\n  \"fallthrough\"\n] @keyword\n\n[\n  \"--\"\n  \"-\"\n  \"-=\"\n  \":=\"\n  \"!\"\n  \"!=\"\n  \"...\"\n  \"*\"\n  \"*\"\n  \"*=\"\n  \"/\"\n  \"/=\"\n  \"&\"\n  \"&&\"\n  \"&=\"\n  \"%\"\n  \"%=\"\n  \"^\"\n  \"^=\"\n  \"+\"\n  \"++\"\n  \"+=\"\n  \"<-\"\n  \"<\"\n  \"<<\"\n  \"<<=\"\n  \"<=\"\n  \"=\"\n  \"==\"\n  \">\"\n  \">=\"\n  \">>\"\n  \">>=\"\n  \"|\"\n  \"|=\"\n  \"||\"\n  \"~\"\n] @operator\n\n; Keywords\n\n(method_spec\n  name: (field_identifier) @method)\n\n; Operators\n\n(method_declaration\n  name: (field_identifier) @method)\n\n(function_declaration\n  name: (identifier) @function)\n\n(call_expression\n  function: (selector_expression\n    field: (field_identifier) @method.call))\n\n; Function definitions\n\n(call_expression\n  function: (identifier) @function.call)\n\n(const_spec\n  name: (identifier) @constant)\n\n; Function calls\n\n((identifier) @constant\n (#eq? @constant \"_\"))\n\n(label_name) @label\n\n(variadic_parameter_declaration (identifier) @parameter)\n\n(parameter_declaration (identifier) @parameter)\n(package_identifier) @namespace\n\n(identifier) @variable\n(field_identifier) @property\n(type_spec name: (type_identifier) @type.definition)\n(type_identifier) @type\n";
pub const GO_INJECTIONS: &str = ";; Forked from https://github.com/nvim-treesitter/nvim-treesitter/blob/master/queries/go/injections.scm\n;; Licensed under the Apache License 2.0\n\n((comment) @injection.content\n (#set! injection.language \"comment\"))\n\n(call_expression\n  (selector_expression) @_function\n  (#any-of? @_function\n    \"regexp.Match\"\n    \"regexp.MatchReader\"\n    \"regexp.MatchString\"\n    \"regexp.Compile\"\n    \"regexp.CompilePOSIX\"\n    \"regexp.MustCompile\"\n    \"regexp.MustCompilePOSIX\")\n  (argument_list\n    . [(raw_string_literal) (interpreted_string_literal)] @injection.content\n    (#offset! @injection.content 0 1 0 -1))\n  (#set! injection.language \"regex\"))\n";
pub const GO_LOCALS: &str = ";; Forked from https://github.com/helix-editor/helix\n;; Licensed under the Mozilla Public License 2.0\n\n; Scopes\n\n(block) @local.scope\n\n; Definitions\n\n(parameter_declaration (identifier) @local.definition)\n(variadic_parameter_declaration (identifier) @local.definition)\n\n(short_var_declaration\n  left: (expression_list\n          (identifier) @local.definition))\n\n(var_spec\n  (identifier) @local.definition)\n\n(for_statement\n (range_clause\n   left: (expression_list\n           (identifier) @local.definition)))\n\n(const_declaration\n (const_spec\n  name: (identifier) @local.definition))\n\n; References\n\n(identifier) @local.reference\n(field_identifier) @local.reference\n";

pub const HTML_HIGHLIGHTS: &str = "\"<!\" @tag.delimiter\n(doctype) @constant\n\n\"=\" @operator\n\n[\n \"<\"\n \">\"\n \"</\"\n \"/>\"\n] @tag.delimiter\n\n((attribute\n   (attribute_name) @_attr\n   (quoted_attribute_value (attribute_value) @text.uri))\n (#match? @_attr \"^(href|src)$\" ))\n\n((element (start_tag (tag_name) @_tag) (text) @text.uri)\n (#eq? @_tag \"a\"))\n\n((element (start_tag (tag_name) @_tag) (text) @text.literal)\n (#match? @_tag \"^(code|kbd)$\" ))\n\n((element (start_tag (tag_name) @_tag) (text) @text.underline)\n (#eq? @_tag \"u\"))\n\n((element (start_tag (tag_name) @_tag) (text) @text.strike)\n (#match? @_tag \"^(s|del)$\" ))\n\n((element (start_tag (tag_name) @_tag) (text) @text.emphasis)\n (#match? @_tag \"^(em|i)$\" ))\n\n((element (start_tag (tag_name) @_tag) (text) @text.strong)\n (#match? @_tag \"^(strong|b)$\" ))\n\n((element (start_tag (tag_name) @_tag) (text) @text.title)\n (#match? @_tag \"^(h[0-9]|title)$\"))\n\n(text) @text @spell\n\n(attribute\n  (quoted_attribute_value) @string)\n(attribute_name) @tag.attribute\n(comment) @comment\n(erroneous_end_tag_name) @error\n(tag_name) @tag\n";
pub const HTML_INJECTIONS: &str = ";; Forked from https://github.com/nvim-treesitter/nvim-treesitter/blob/master/queries/html/injections.scm\n;; Licensed under the Apache License 2.0\n\n\n;; Forked from https://github.com/nvim-treesitter/nvim-treesitter/blob/master/queries/html_tags/injections.scm\n;; Licensed under the Apache License 2.0\n\n; <style>...</style>\n; <style blocking> ...</style>\n; Add \"lang\" to predicate check so that vue/svelte can inherit this\n; without having this element being captured twice\n(\n  (style_element\n    (start_tag) @_no_type_lang\n      (#not-lua-match? @_no_type_lang \"%slang%s*=\")\n      (#not-lua-match? @_no_type_lang \"%stype%s*=\")\n    (raw_text) @injection.content)\n  (#set! injection.language \"css\"))\n\n(\n  (style_element\n    (start_tag\n      (attribute\n        (attribute_name) @_type\n        (quoted_attribute_value (attribute_value) @_css)))\n    (raw_text) @injection.content)\n  (#eq? @_type \"type\")\n  (#eq? @_css \"text/css\")\n  (#set! injection.language \"css\"))\n\n; <script>...</script>\n; <script defer>...</script>\n(\n  (script_element\n    (start_tag) @_no_type_lang\n      (#not-lua-match? @_no_type_lang \"%slang%s*=\")\n      (#not-lua-match? @_no_type_lang \"%stype%s*=\")\n    (raw_text) @injection.content)\n  (#set! injection.language \"javascript\"))\n\n; <script type=\"language-name\">\n(script_element\n   (start_tag\n      ((attribute\n           (attribute_name) @_attr (#eq? @_attr \"type\")\n           (quoted_attribute_value (attribute_value) @injection.language))))\n   (raw_text) @injection.content)\n\n; <a style=\"/* css */\">\n((attribute\n   (attribute_name) @_attr\n   (quoted_attribute_value (attribute_value) @injection.content))\n (#eq? @_attr \"style\")\n (#set! injection.language \"css\"))\n\n; lit-html style template interpolation\n; <a @click=${e => console.log(e)}>\n; <a @click=\"${e => console.log(e)}\">\n((attribute\n  (quoted_attribute_value (attribute_value) @injection.content))\n  (#lua-match? @injection.content \"%${\")\n  (#offset! @injection.content 0 2 0 -1)\n  (#set! injection.language \"javascript\"))\n((attribute\n  (attribute_value) @injection.content)\n  (#lua-match? @injection.content \"%${\")\n  (#offset! @injection.content 0 2 0 -2)\n  (#set! injection.language \"javascript\"))\n\n((comment) @injection.content\n (#set! injection.language \"comment\"))\n\n; <input pattern=\"[0-9]\"> or <input pattern=[0-9]>\n(element (_\n  (tag_name) @_tagname (#eq? @_tagname \"input\")\n  ((attribute\n    (attribute_name) @_attr [\n      (quoted_attribute_value (attribute_value) @injection.content)\n      (attribute_value) @injection.content\n    ] (#eq? @_attr \"pattern\") (#set! injection.language \"regex\"))\n)))\n\n; <input type=\"checkbox\" onchange=\"this.closest('form').elements.output.value = this.checked\">\n(attribute\n  (attribute_name) @_name\n  (#lua-match? @_name \"^on[a-z]+$\")\n  (quoted_attribute_value (attribute_value) @injection.content)\n  (#set! injection.language \"javascript\"))\n\n(element\n  (start_tag\n    (tag_name) @_py_script)\n  (text) @injection.content\n  (#any-of? @_py_script \"py-script\" \"py-repl\")\n  (#set! injection.language \"python\"))\n\n(script_element\n  (start_tag\n    (attribute\n      (attribute_name) @_attr\n      (quoted_attribute_value\n        (attribute_value) @_type)))\n  (raw_text) @injection.content\n  (#eq? @_attr \"type\")\n  ; not adding type=\"py\" here as it's handled by html_tags\n  (#any-of? @_type \"pyscript\" \"py-script\")\n  (#set! injection.language \"python\"))\n\n(element\n  (start_tag\n    (tag_name) @_py_config)\n  (text) @injection.content\n  (#eq? @_py_config \"py-config\")\n  (#set! injection.language \"toml\"))\n";
pub const HTML_LOCALS: &str = "";

pub const JAVA_HIGHLIGHTS: &str = "((line_comment) @comment.documentation\n  (#match? @comment.documentation \"^///$\" ))\n((line_comment) @comment.documentation\n  (#match? @comment.documentation \"^///[^/]\" ))\n\n((block_comment) @comment.documentation\n  (#match? @comment.documentation \"^/[*][*][^*].*[*]/$\" ))\n\n[\n  (line_comment)\n  (block_comment)\n] @comment @spell\n\n(labeled_statement\n  (identifier) @label)\n\n; Comments\n\n[\n  \"throw\"\n  \"throws\"\n  \"finally\"\n  \"try\"\n  \"catch\"\n] @exception\n\n; Labels\n\n(type_parameters [ \"<\" \">\" ] @punctuation.bracket)\n\n; Exceptions\n\n(type_arguments [ \"<\" \">\" ] @punctuation.bracket)\n[ \"(\" \")\" ] @punctuation.bracket\n\n[ \"[\" \"]\" ] @punctuation.bracket\n\n[ \"{\" \"}\" ] @punctuation.bracket\n\n[\n  \";\"\n  \".\"\n  \"...\"\n  \",\"\n] @punctuation.delimiter\n\n[\n  \"exports\"\n  \"import\"\n  \"module\"\n  \"opens\"\n  \"package\"\n  \"provides\"\n  \"requires\"\n  \"uses\"\n] @include\n\n; Punctuation\n\n[\n  \"for\"\n  \"while\"\n  \"do\"\n  \"continue\"\n  \"break\"\n] @repeat\n\n; Includes\n\n(ternary_expression [\"?\" \":\"] @conditional.ternary)\n\n; Loops\n\n[\n  \"if\"\n  \"else\"\n  \"switch\"\n  \"case\"\n] @conditional\n\n[\n  \"new\"\n] @keyword.operator\n\n; Conditionals\n\n[\n  \"return\"\n  \"yield\"\n] @keyword.return\n\n[\n  \"transient\"\n  \"volatile\"\n] @storageclass\n\n(modifiers\n  \"synchronized\" @type.qualifier)\n\n[\n  \"abstract\"\n  \"final\"\n  \"native\"\n  \"non-sealed\"\n  \"open\"\n  \"private\"\n  \"protected\"\n  \"public\"\n  \"sealed\"\n  \"static\"\n  \"strictfp\"\n  \"transitive\"\n] @type.qualifier\n\n(synchronized_statement\n  \"synchronized\" @keyword)\n\n[\n  \"assert\"\n  \"class\"\n  \"record\"\n  \"default\"\n  \"enum\"\n  \"extends\"\n  \"implements\"\n  \"instanceof\"\n  \"interface\"\n  \"permits\"\n  \"to\"\n  \"with\"\n] @keyword\n\n(null_literal) @constant.builtin\n\n; Keywords\n\n[\n  (true)\n  (false)\n] @boolean\n\n[\n  (decimal_floating_point_literal)\n  (hex_floating_point_literal)\n] @float\n\n[\n  (hex_integer_literal)\n  (decimal_integer_literal)\n  (octal_integer_literal)\n  (binary_integer_literal)\n] @number\n\n(character_literal) @character\n\n(escape_sequence) @string.escape\n\n(string_literal) @string\n\n(this) @variable.builtin\n\n; Literals\n\n((identifier) @constant\n  (#match? @constant \"^[A-Z_][A-Z[0-9]_]+$\" ))\n\n[\n  (boolean_type)\n  (integral_type)\n  (floating_point_type)\n  (void_type)\n] @type.builtin\n\n; Variables\n\n(field_access\n  field: (identifier) @field)\n\n(field_declaration\n  declarator: (variable_declarator\n    name: (identifier) @field))\n\n((scoped_identifier\n  scope: (identifier) @type)\n  (#match? @type \"^[A-Z]\" ))\n\n; Fields\n\n((field_access\n  object: (identifier) @type)\n  (#match? @type \"^[A-Z]\" ))\n((method_reference\n  . (identifier) @type)\n (#match? @type \"^[A-Z]\" ))\n\n((method_invocation\n  object: (identifier) @type)\n (#match? @type \"^[A-Z]\" ))\n(type_identifier) @type\n(constructor_declaration\n  name: (identifier) @type)\n(enum_declaration\n  name: (identifier) @type)\n(record_declaration\n  name: (identifier) @type)\n(class_declaration\n  name: (identifier) @type)\n(interface_declaration\n  name: (identifier) @type)\n[\n  \"@\"\n  \"+\"\n  \":\"\n  \"++\"\n  \"-\"\n  \"--\"\n  \"&\"\n  \"&&\"\n  \"|\"\n  \"||\"\n  \"!\"\n  \"!=\"\n  \"==\"\n  \"*\"\n  \"/\"\n  \"%\"\n  \"<\"\n  \"<=\"\n  \">\"\n  \">=\"\n  \"=\"\n  \"-=\"\n  \"+=\"\n  \"*=\"\n  \"/=\"\n  \"%=\"\n  \"->\"\n  \"^\"\n  \"^=\"\n  \"&=\"\n  \"|=\"\n  \"~\"\n  \">>\"\n  \">>>\"\n  \"<<\"\n  \"::\"\n] @operator\n\n; Types\n\n(marker_annotation\n  name: (identifier) @attribute)\n\n; Operators\n\n(annotation\n  name: (identifier) @attribute)\n(lambda_expression\n    parameters: (identifier) @parameter) ; x -> ...\n\n; Annotations\n\n(inferred_parameters (identifier) @parameter) ; (x,y) -> ...\n\n(spread_parameter\n (variable_declarator\n   name: (identifier) @parameter)) ; int... foo\n\n;; Lambda parameter\n\n(catch_formal_parameter\n  name: (identifier) @parameter)\n\n(formal_parameter\n  name: (identifier) @parameter)\n\n(super) @function.builtin\n\n; Parameters\n\n(method_invocation\n  name: (identifier) @method.call)\n\n(method_declaration\n  name: (identifier) @method)\n(identifier) @variable\n\n; Methods\n\n";
pub const JAVA_INJECTIONS: &str = "([(line_comment) (block_comment)] @injection.content\n (#set! injection.language \"comment\"))\n";
pub const JAVA_LOCALS: &str = ";; Forked from https://github.com/nvim-treesitter/nvim-treesitter/blob/master/queries/java/locals.scm\n;; Licensed under the Apache License 2.0\n\n;; SCOPES\n\n; declarations\n\n(program) @local.scope\n(class_declaration\n  body: (_) @local.scope)\n(record_declaration\n  body: (_) @local.scope)\n(enum_declaration\n  body: (_) @local.scope)\n(lambda_expression) @local.scope\n(enhanced_for_statement) @local.scope\n\n; block\n\n(block) @local.scope\n\n; if/else\n\n(if_statement) @local.scope ; if+else\n(if_statement\n  consequence: (_) @local.scope) ; if body in case there are no braces\n(if_statement\n  alternative: (_) @local.scope) ; else body in case there are no braces\n\n; try/catch\n\n(try_statement) @local.scope ; covers try+catch, individual try and catch are covered by (block)\n(catch_clause) @local.scope ; needed because `Exception` variable\n\n; loops\n\n(for_statement) @local.scope ; whole for_statement because loop iterator variable\n(for_statement         ; \"for\" body in case there are no braces\n  body: (_) @local.scope)\n(do_statement\n  body: (_) @local.scope)\n(while_statement\n  body: (_) @local.scope)\n\n; Functions\n\n(constructor_declaration) @local.scope\n(method_declaration) @local.scope\n\n;; DEFINITIONS\n\n(package_declaration\n  (identifier) @local.definition)\n\n(class_declaration\n  name: (identifier) @local.definition)\n(record_declaration\n  name: (identifier) @local.definition)\n\n(enum_declaration\n  name: (identifier) @local.definition)\n\n(method_declaration\n  name: (identifier) @local.definition)\n\n(local_variable_declaration\n  declarator: (variable_declarator\n                name: (identifier) @local.definition))\n(enhanced_for_statement ; for (var item : items) {\n  name: (identifier) @local.definition)\n\n(formal_parameter\n  name: (identifier) @local.definition)\n(catch_formal_parameter\n  name: (identifier) @local.definition)\n(inferred_parameters (identifier) @local.definition) ; (x,y) -> ...\n(lambda_expression\n    parameters: (identifier) @local.definition) ; x -> ...\n\n; ((scoped_identifier\n;   (identifier) @local.definition)\n;  (#has-ancestor? @local.definition import_declaration))\n\n(field_declaration\n  declarator: (variable_declarator\n                name: (identifier) @local.definition))\n\n;; REFERENCES\n\n(identifier) @local.reference\n\n(type_identifier) @local.reference\n";

pub const JAVASCRIPT_HIGHLIGHTS: &str = "(optional_chain) @punctuation.delimiter\n(formal_parameters\n  (assignment_pattern\n    left: (identifier) @parameter))\n\n;; punctuation\n(arrow_function\n  parameter: (identifier) @parameter)\n\n;; optional parameters\n(formal_parameters\n  (array_pattern\n    (identifier) @parameter))\n\n;; a => null\n(formal_parameters\n  (object_pattern\n    (pair_pattern\n      value: (identifier) @parameter)))\n\n;; ([ a ]) => null\n(formal_parameters\n  (object_pattern\n    (shorthand_property_identifier_pattern) @parameter))\n\n;; ({ a: b }) => null\n(formal_parameters\n  (rest_pattern\n    (identifier) @parameter))\n\n;; ({ a }) => null\n(formal_parameters (identifier) @parameter)\n\n(jsx_text) @none\n\n;;; Parameters\n(jsx_self_closing_element ((nested_identifier (identifier) @tag (identifier) @constructor)))\n\n(jsx_self_closing_element ((identifier) @constructor\n (#match? @constructor \"^[A-Z]\" )))\n\n; Handle the dot operator effectively - <My.Component />\n(jsx_closing_element ((nested_identifier (identifier) @tag (identifier) @constructor)))\n\n(jsx_closing_element ((identifier) @constructor\n (#match? @constructor \"^[A-Z]\" )))\n\n; Handle the dot operator effectively - </My.Component>\n(jsx_opening_element ((nested_identifier (identifier) @tag (identifier) @constructor)))\n\n(jsx_opening_element ((identifier) @constructor\n (#match? @constructor \"^[A-Z]\" )))\n\n; Handle the dot operator effectively - <My.Component>\n(jsx_self_closing_element\n  name: (identifier) @tag)\n\n(jsx_closing_element\n  name: (identifier) @tag)\n\n(jsx_opening_element\n  name: (identifier) @tag)\n\n(jsx_attribute (property_identifier) @tag.attribute)\n\n(jsx_fragment [\">\" \"<\" \"/\"] @tag.delimiter)\n(jsx_self_closing_element [\"/\" \">\" \"<\"] @tag.delimiter)\n(jsx_element\n  close_tag: (jsx_closing_element [\"<\" \"/\" \">\"] @tag.delimiter))\n(jsx_element\n  open_tag: (jsx_opening_element [\"<\" \">\"] @tag.delimiter))\n(switch_default\n  \"default\" @conditional)\n\n\n;; Forked from https://github.com/nvim-treesitter/nvim-treesitter/blob/master/queries/jsx/highlights.scm\n;; Licensed under the Apache License 2.0\n\n(export_statement\n  \"default\" @keyword)\n[\n  \"throw\"\n  \"try\"\n  \"catch\"\n  \"finally\"\n] @exception\n\n[\n  \"new\"\n  \"delete\"\n] @keyword.operator\n\n[\n  \"function\"\n] @keyword.function\n\n[\n  \"return\"\n  \"yield\"\n] @keyword.return\n\n[\n  \"async\"\n  \"await\"\n] @keyword.coroutine\n\n[\n  \"break\"\n  \"class\"\n  \"const\"\n  \"debugger\"\n  \"export\"\n  \"extends\"\n  \"get\"\n  \"in\"\n  \"instanceof\"\n  \"let\"\n  \"set\"\n  \"static\"\n  \"target\"\n  \"typeof\"\n  \"var\"\n  \"with\"\n] @keyword\n\n[\n  \"for\"\n  \"of\"\n  \"do\"\n  \"while\"\n  \"continue\"\n] @repeat\n\n(namespace_import \"as\" @include)\n\n(namespace_export \"as\" @include)\n(import_specifier \"as\" @include)\n(export_specifier \"as\" @include)\n[\n  \"import\"\n  \"from\"\n] @include\n\n[\n  \"if\"\n  \"else\"\n  \"switch\"\n  \"case\"\n] @conditional\n\n((template_substitution [\"${\" \"}\"] @punctuation.special) @none)\n\n; Keywords\n;----------\n\n[\n  \"(\"\n  \")\"\n  \"[\"\n  \"]\"\n  \"{\"\n  \"}\"\n] @punctuation.bracket\n\n(unary_expression [\"delete\" \"void\" \"typeof\"] @keyword.operator)\n\n(unary_expression [\"!\" \"~\" \"-\" \"+\"] @operator)\n(ternary_expression [\"?\" \":\"] @conditional.ternary)\n(binary_expression \"/\" @operator)\n[\n  \"--\"\n  \"-\"\n  \"-=\"\n  \"&&\"\n  \"+\"\n  \"++\"\n  \"+=\"\n  \"&=\"\n  \"/=\"\n  \"**=\"\n  \"<<=\"\n  \"<\"\n  \"<=\"\n  \"<<\"\n  \"=\"\n  \"==\"\n  \"===\"\n  \"!=\"\n  \"!==\"\n  \"=>\"\n  \">\"\n  \">=\"\n  \">>\"\n  \"||\"\n  \"%\"\n  \"%=\"\n  \"*\"\n  \"**\"\n  \">>>\"\n  \"&\"\n  \"|\"\n  \"^\"\n  \"??\"\n  \"*=\"\n  \">>=\"\n  \">>>=\"\n  \"^=\"\n  \"|=\"\n  \"&&=\"\n  \"||=\"\n  \"??=\"\n] @operator\n\n(switch_case \":\" @punctuation.delimiter)\n\n(pair_pattern \":\" @punctuation.delimiter)\n(pair \":\" @punctuation.delimiter)\n\",\" @punctuation.delimiter\n\n\".\" @punctuation.delimiter\n\";\" @punctuation.delimiter\n\"...\" @punctuation.special\n\n((identifier) @number\n  (#match? @number \"^(NaN|Infinity)$\" ))\n\n; Punctuation\n;------------\n\n(number) @number\n(regex \"/\" @punctuation.bracket) ; Regex delimiters\n\n(regex_pattern) @string.regex\n(escape_sequence) @string.escape\n(template_string) @string\n(string) @string @spell\n((string_fragment) @preproc\n (#eq? @preproc \"use strict\"))\n\n(hash_bang_line) @preproc\n\n((comment) @comment.documentation\n  (#match? @comment.documentation \"^/[*][*][^*].*[*]/$\" ))\n\n(comment) @comment @spell\n\n[\n  (null)\n  (undefined)\n] @constant.builtin\n\n[\n  (true)\n  (false)\n] @boolean\n\n[\n  (this)\n  (super)\n] @variable.builtin\n\n(namespace_import\n  (identifier) @namespace)\n\n; Literals\n;---------\n\n(new_expression\n  constructor: (identifier) @constructor)\n\n; Variables\n;----------\n(call_expression\n  function: (member_expression\n    property: [(property_identifier) (private_property_identifier)] @method.call))\n\n; Constructor\n;------------\n\n(call_expression\n  function: (identifier) @function.call)\n\n(assignment_expression\n  left: (identifier) @function\n  right: (function))\n\n; Function and method calls\n;--------------------------\n\n(assignment_expression\n  left: (identifier) @function\n  right: (arrow_function))\n(variable_declarator\n  name: (identifier) @function\n  value: (function))\n\n(variable_declarator\n  name: (identifier) @function\n  value: (arrow_function))\n(assignment_expression\n  left: (member_expression\n    property: (property_identifier) @method)\n  right: (function))\n\n(assignment_expression\n  left: (member_expression\n    property: (property_identifier) @method)\n  right: (arrow_function))\n(pair\n  key: (property_identifier) @method\n  value: (arrow_function))\n\n(pair\n  key: (property_identifier) @method\n  value: (function))\n(method_definition\n  name: (property_identifier) @constructor\n  (#eq? @constructor \"constructor\"))\n\n(method_definition\n  name: [(property_identifier) (private_property_identifier)] @method)\n(generator_function_declaration\n  name: (identifier) @function)\n(generator_function\n  name: (identifier) @function)\n(function_declaration\n  name: (identifier) @function)\n(function\n  name: (identifier) @function)\n((identifier) @function.builtin\n (#match? @function.builtin \"^(eval|isFinite|isNaN|parseFloat|parseInt|decodeURI|decodeURIComponent|encodeURI|encodeURIComponent|require)$\" ))\n\n; Function and method definitions\n;--------------------------------\n\n((identifier) @namespace.builtin\n (#eq? @namespace.builtin \"Intl\"))\n\n((identifier) @type.builtin\n (#match? @type.builtin \"^(Object|Function|Boolean|Symbol|Number|Math|Date|String|RegExp|Map|Set|WeakMap|WeakSet|Promise|Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array|ArrayBuffer|DataView|Error|EvalError|InternalError|RangeError|ReferenceError|SyntaxError|TypeError|URIError)$\" ))\n\n((identifier) @variable.builtin\n (#match? @variable.builtin \"^(arguments|module|console|window|document)$\" ))\n\n((shorthand_property_identifier) @constant\n (#match? @constant \"^_*[A-Z][A-Z[0-9]_]*$\" ))\n\n((identifier) @constant\n (#match? @constant \"^_*[A-Z][A-Z[0-9]_]*$\" ))\n\n((identifier) @type\n (#match? @type \"^[A-Z]\" ))\n\n(variable_declarator\n  name: (object_pattern\n    (shorthand_property_identifier_pattern))) @variable\n\n; Special identifiers\n;--------------------\n\n(private_property_identifier) @property\n\n(shorthand_property_identifier) @property\n(property_identifier) @property\n(identifier) @variable\n\n; Properties\n;-----------\n\n";
pub const JAVASCRIPT_INJECTIONS: &str = "\n;; Forked from https://github.com/nvim-treesitter/nvim-treesitter/blob/master/queries/ecma/injections.scm\n;; Licensed under the Apache License 2.0\n\n(((comment) @_jsdoc_comment\n  (#lua-match? @_jsdoc_comment \"^/[*][*][^*].*[*]/$\")) @injection.content\n  (#set! injection.language \"jsdoc\"))\n\n((comment) @injection.content\n (#set! injection.language \"comment\"))\n\n; html(`...`), html`...`, sql(...) etc\n(call_expression\n function: ((identifier) @injection.language)\n arguments: [\n             (arguments\n              (template_string) @injection.content)\n             (template_string) @injection.content\n            ]\n     (#offset! @injection.content 0 1 0 -1)\n     (#not-eq? @injection.language \"svg\"))\n\n; svg`...` or svg(`...`), which uses the html parser, so is not included in the previous query\n(call_expression\n function: ((identifier) @_name (#eq? @_name \"svg\"))\n arguments: [\n             (arguments\n              (template_string) @injection.content)\n             (template_string) @injection.content\n            ]\n     (#offset! @injection.content 0 1 0 -1)\n     (#set! injection.language \"html\"))\n\n\n(call_expression\n function: ((identifier) @_name\n   (#eq? @_name \"gql\"))\n arguments: ((template_string) @injection.content\n   (#offset! @injection.content 0 1 0 -1)\n   (#set! injection.language \"graphql\")))\n\n(call_expression\n function: ((identifier) @_name\n   (#eq? @_name \"hbs\"))\n arguments: ((template_string) @injection.content\n   (#offset! @injection.content 0 1 0 -1)\n   (#set! injection.language \"glimmer\")))\n\n(\n (glimmer_template) @injection.content\n (#set! injection.language \"glimmer\"))\n\n; styled.div`<css>`\n(call_expression\n function: (member_expression\n   object: (identifier) @_name\n     (#eq? @_name \"styled\"))\n arguments: ((template_string) @injection.content\n   (#offset! @injection.content 0 1 0 -1)\n   (#set! injection.language \"css\")))\n\n; styled(Component)`<css>`\n(call_expression\n function: (call_expression\n   function: (identifier) @_name\n     (#eq? @_name \"styled\"))\n arguments: ((template_string) @injection.content\n   (#offset! @injection.content 0 1 0 -1)\n   (#set! injection.language \"css\")))\n\n; styled.div.attrs({ prop: \"foo\" })`<css>`\n(call_expression\n function: (call_expression\n   function: (member_expression\n    object: (member_expression\n      object: (identifier) @_name\n        (#eq? @_name \"styled\"))))\n arguments: ((template_string) @injection.content\n   (#offset! @injection.content 0 1 0 -1)\n   (#set! injection.language \"css\")))\n\n\n; styled(Component).attrs({ prop: \"foo\" })`<css>`\n(call_expression\n function: (call_expression\n   function: (member_expression\n    object: (call_expression\n      function: (identifier) @_name\n        (#eq? @_name \"styled\"))))\n arguments: ((template_string) @injection.content\n   (#offset! @injection.content 0 1 0 -1)\n   (#set! injection.language \"css\")))\n\n((regex_pattern) @injection.content (#set! injection.language \"regex\"))\n\n; ((comment) @_gql_comment\n;   (#eq? @_gql_comment \"/* GraphQL */\")\n;   (template_string) @graphql)\n\n((template_string) @injection.content\n  (#lua-match? @injection.content \"^`#graphql\")\n  (#offset! @injection.content 0 1 0 -1)\n  (#set! injection.language \"graphql\"))\n\n; el.innerHTML = `<html>`\n(assignment_expression\n  left: (member_expression\n          property: (property_identifier) @_prop\n           (#any-of? @_prop \"innerHTML\" \"outerHTML\"))\n  right: (template_string) @injection.content\n    (#offset! @injection.content 0 1 0 -1)\n    (#set! injection.language \"html\"))\n\n; el.innerHTML = '<html>'\n(assignment_expression\n   left: (member_expression\n           property: (property_identifier) @_prop\n            (#any-of? @_prop \"innerHTML\" \"outerHTML\"))\n   right: (string) @injection.content\n            (#offset! @injection.content 0 1 0 -1)\n            (#set! injection.language \"html\"))\n\n\n;; Forked from https://github.com/nvim-treesitter/nvim-treesitter/blob/master/queries/jsx/injections.scm\n;; Licensed under the Apache License 2.0\n\n; Styled Jsx <style jsx>\n(jsx_element\n  (jsx_opening_element\n    (identifier) @_name (#eq? @_name \"style\")\n    (jsx_attribute) @_attr (#eq? @_attr \"jsx\"))\n  (jsx_expression (template_string) @injection.content\n    (#offset! @injection.content 0 1 0 -1)\n    (#set! injection.language)))\n\n";
pub const JAVASCRIPT_LOCALS: &str = "\n;; Forked from https://github.com/nvim-treesitter/nvim-treesitter/blob/master/queries/ecma/locals.scm\n;; Licensed under the Apache License 2.0\n\n; Scopes\n;-------\n\n(statement_block) @local.scope\n(function) @local.scope\n(arrow_function) @local.scope\n(function_declaration) @local.scope\n(method_definition) @local.scope\n(for_statement) @local.scope\n(for_in_statement) @local.scope\n(catch_clause) @local.scope\n\n; Definitions\n;------------\n\n(variable_declarator\n  name: (identifier) @local.definition)\n\n(import_specifier\n  (identifier) @local.definition)\n\n(namespace_import\n  (identifier) @local.definition)\n\n(function_declaration\n  ((identifier) @local.definition)\n   (#set! definition.var.scope parent))\n\n(method_definition\n  ((property_identifier) @local.definition)\n   (#set! definition.var.scope parent))\n\n; References\n;------------\n\n(identifier) @local.reference\n(shorthand_property_identifier) @local.reference\n\n; Both properties are matched here.\n;\n;   class Foo {\n;     this.#bar = \"baz\";\n;     this.quuz = \"qux\";\n;   }\n(field_definition\n  property: [(property_identifier) (private_property_identifier)] @local.definition)\n\n; this.foo = \"bar\"\n(assignment_expression\n  left: (member_expression\n    object: (this)\n    property: (property_identifier) @local.definition))\n\n(formal_parameters\n  (identifier) @local.definition)\n\n; function(arg = []) {\n(formal_parameters\n  (assignment_pattern\n    left: (identifier) @local.definition))\n\n; x => x\n(arrow_function\n  parameter: (identifier) @local.definition)\n\n;; ({ a }) => null\n(formal_parameters\n  (object_pattern\n    (shorthand_property_identifier_pattern) @local.definition))\n\n;; ({ a: b }) => null\n(formal_parameters\n  (object_pattern\n    (pair_pattern\n      value: (identifier) @local.definition)))\n\n;; ([ a ]) => null\n(formal_parameters\n  (array_pattern\n    (identifier) @local.definition))\n\n(formal_parameters\n  (rest_pattern\n    (identifier) @local.definition))\n\n; Both methods are matched here.\n;\n;   class Foo {\n;     #bar(x) { x }\n;     baz(y) { y }\n;   }\n(method_definition\n  ([(property_identifier) (private_property_identifier)] @local.definition)\n   (#set! definition.var.scope parent))\n\n; this.foo()\n(member_expression\n  object: (this)\n  property: (property_identifier) @local.reference)\n";

pub const JSON_HIGHLIGHTS: &str = "((escape_sequence) @conceal\n (#eq? @conceal \"\\\\\\\"\")\n (#set! conceal \"\\\"\"))\n(escape_sequence) @string.escape\n((\"\\\"\" @conceal)\n (#set! conceal \"\"))\n\n[\n \"[\" \"]\"\n \"{\" \"}\"\n] @punctuation.bracket\n\n[\",\" \":\"] @punctuation.delimiter\n\n(ERROR) @error\n\n(string_content) @spell\n\n(array (string) @string)\n\n(pair value: (string) @string)\n\n(pair key: (string) @label)\n(number) @number\n\n(null) @constant.builtin\n\n[\n (true)\n (false)\n] @boolean\n\n";
pub const JSON_INJECTIONS: &str = "";
pub const JSON_LOCALS: &str = "";

pub const PYTHON_HIGHLIGHTS: &str = "(ERROR) @error\n((class_definition\n  (block\n    (function_definition\n      name: (identifier) @constructor)))\n (#match? @constructor \"^(__new__|__init__)$\" ))\n\n;; Error\n((class_definition\n  body: (block\n          (expression_statement\n            (assignment\n              left: (_\n                     (identifier) @field)))))\n (#match? @field \"^([A-Z])@!.*$\"))\n\n((class_definition\n  body: (block\n          (expression_statement\n            (assignment\n              left: (identifier) @field))))\n (#match? @field \"^([A-Z])@!.*$\"))\n(class_definition\n  superclasses: (argument_list\n                  (identifier) @type))\n\n(class_definition\n  body: (block\n          (function_definition\n            name: (identifier) @method)))\n\n(class_definition name: (identifier) @type)\n\n[\",\" \".\" \":\" \";\" (ellipsis)] @punctuation.delimiter\n\n;; Class definitions\n\n(interpolation\n  \"{\" @punctuation.special\n  \"}\" @punctuation.special)\n\n[\"(\" \")\" \"[\" \"]\" \"{\" \"}\"] @punctuation.bracket\n\n(try_statement\n  (else_clause\n    \"else\" @exception))\n\n(raise_statement \"from\" @exception)\n\n[\n  \"try\"\n  \"except\"\n  \"except*\"\n  \"raise\"\n  \"finally\"\n] @exception\n\n[\"for\" \"while\" \"break\" \"continue\"] @repeat\n\n[\"if\" \"elif\" \"else\" \"match\" \"case\"] @conditional\n\n(aliased_import \"as\" @include)\n\n\"import\" @include\n\n(import_from_statement \"from\" @include)\n(future_import_statement\n  \"from\" @include\n  \"__future__\" @constant.builtin)\n(yield \"from\" @keyword.return)\n\n[\n  \"return\"\n  \"yield\"\n] @keyword.return\n[\n  \"async\"\n  \"await\"\n] @keyword.coroutine\n\n[\n  \"assert\"\n  \"class\"\n  \"exec\"\n  \"global\"\n  \"nonlocal\"\n  \"pass\"\n  \"print\"\n  \"with\"\n  \"as\"\n] @keyword\n\n[\n  \"def\"\n  \"lambda\"\n] @keyword.function\n\n[\n  \"and\"\n  \"in\"\n  \"is\"\n  \"not\"\n  \"or\"\n  \"is not\"\n  \"not in\"\n\n  \"del\"\n] @keyword.operator\n\n[\n  \"-\"\n  \"-=\"\n  \":=\"\n  \"!=\"\n  \"*\"\n  \"**\"\n  \"**=\"\n  \"*=\"\n  \"/\"\n  \"//\"\n  \"//=\"\n  \"/=\"\n  \"&\"\n  \"&=\"\n  \"%\"\n  \"%=\"\n  \"^\"\n  \"^=\"\n  \"+\"\n  \"+=\"\n  \"<\"\n  \"<<\"\n  \"<<=\"\n  \"<=\"\n  \"<>\"\n  \"=\"\n  \"==\"\n  \">\"\n  \">=\"\n  \">>\"\n  \">>=\"\n  \"@\"\n  \"@=\"\n  \"|\"\n  \"|=\"\n  \"~\"\n  \"->\"\n] @operator\n\n; Keywords\n(function_definition\n  body:\n    (block\n      . (expression_statement (string) @string.documentation @spell)))\n\n; Tokens\n\n(class_definition\n  body:\n    (block\n      . (expression_statement (string) @string.documentation @spell)))\n\n(module . (expression_statement (string) @string.documentation @spell))\n\n(escape_sequence) @string.escape\n\n; doc-strings\n\n(string) @string\n((module . (comment) @preproc)\n  (#match? @preproc \"^#!/\"))\n\n(comment) @comment @spell\n\n(float) @float\n\n(integer) @number\n((identifier) @variable.builtin\n (#eq? @variable.builtin \"cls\"))\n\n((identifier) @variable.builtin\n (#eq? @variable.builtin \"self\"))\n[(true) (false)] @boolean\n(none) @constant.builtin\n(parameters\n  (dictionary_splat_pattern ; **kwargs\n    (identifier) @parameter))\n\n\n;; Literals\n\n(parameters\n  (list_splat_pattern ; *args\n    (identifier) @parameter))\n(typed_default_parameter\n  (identifier) @parameter)\n; Variadic parameters *args, **kwargs\n(typed_parameter\n  (identifier) @parameter)\n(default_parameter\n  name: (identifier) @parameter)\n(keyword_argument\n  name: (identifier) @parameter)\n; Naming parameters on call-site\n(lambda_parameters\n  (tuple_pattern\n    (identifier) @parameter))\n; Default parameters\n(lambda_parameters\n  (identifier) @parameter)\n(parameters\n  (identifier) @parameter)\n;; Lambda parameters\n((call\n  function: (identifier) @_isinstance\n  arguments: (argument_list\n    (_)\n    (identifier) @type))\n (#eq? @_isinstance \"isinstance\"))\n\n;; Normal parameters\n(type\n  (subscript\n    (identifier) @type)) ; type subscript: Tuple[int]\n\n(type (identifier) @type)\n(function_definition\n  name: (identifier) @function)\n\n((call\n  function: (identifier) @function.builtin)\n (#match? @function.builtin \"^(abs|all|any|ascii|bin|bool|breakpoint|bytearray|bytes|callable|chr|classmethod|compile|complex|delattr|dict|dir|divmod|enumerate|eval|exec|filter|float|format|frozenset|getattr|globals|hasattr|hash|help|hex|id|input|int|isinstance|issubclass|iter|len|list|locals|map|max|memoryview|min|next|object|oct|open|ord|pow|print|property|range|repr|reversed|round|set|setattr|slice|sorted|staticmethod|str|sum|super|tuple|type|vars|zip|__import__)$\" ))\n\n;; Function definitions\n\n((decorator\n  (identifier) @attribute.builtin)\n (#match? @attribute.builtin \"^(classmethod|property)$\" ))\n\n;; Builtin functions\n\n(decorator\n  (call (attribute\n          attribute: (identifier) @attribute)))\n\n(decorator\n  (call (identifier) @attribute))\n(decorator\n  (attribute\n    attribute: (identifier) @attribute))\n(decorator\n  (identifier) @attribute)\n((decorator \"@\" @attribute)\n (#set! \"priority\" 101))\n\n((call\n  function: (attribute\n              attribute: (identifier) @constructor))\n (#match? @constructor \"^[A-Z]\" ))\n\n;; Decorators\n\n((call\n   function: (identifier) @constructor)\n (#match? @constructor \"^[A-Z]\" ))\n\n(call\n  function: (attribute\n              attribute: (identifier) @method.call))\n\n(call\n  function: (identifier) @function.call)\n\n((assignment\n  left: (identifier) @type.definition\n  right: (call\n    function: (identifier) @_func))\n (#match? @_func \"^(TypeVar|NewType)$\" ))\n\n; Function calls\n\n((assignment\n  left: (identifier) @type.definition\n  (type (identifier) @_annotation))\n (#eq? @_annotation \"TypeAlias\"))\n\n((identifier) @type.builtin\n (#match? @type.builtin \"^(BaseException|Exception|ArithmeticError|BufferError|LookupError|AssertionError|AttributeError|EOFError|FloatingPointError|GeneratorExit|ImportError|ModuleNotFoundError|IndexError|KeyError|KeyboardInterrupt|MemoryError|NameError|NotImplementedError|OSError|OverflowError|RecursionError|ReferenceError|RuntimeError|StopIteration|StopAsyncIteration|SyntaxError|IndentationError|TabError|SystemError|SystemExit|TypeError|UnboundLocalError|UnicodeError|UnicodeEncodeError|UnicodeDecodeError|UnicodeTranslateError|ValueError|ZeroDivisionError|EnvironmentError|IOError|WindowsError|BlockingIOError|ChildProcessError|ConnectionError|BrokenPipeError|ConnectionAbortedError|ConnectionRefusedError|ConnectionResetError|FileExistsError|FileNotFoundError|InterruptedError|IsADirectoryError|NotADirectoryError|PermissionError|ProcessLookupError|TimeoutError|Warning|UserWarning|DeprecationWarning|PendingDeprecationWarning|SyntaxWarning|RuntimeWarning|FutureWarning|ImportWarning|UnicodeWarning|BytesWarning|ResourceWarning|bool|int|float|complex|list|tuple|range|str|bytes|bytearray|memoryview|set|frozenset|dict|type|object)$\" ))\n\n((attribute\n    attribute: (identifier) @field)\n (#match? @field \"^([A-Z])@!.*$\"))\n\n((identifier) @constant.builtin\n (#match? @constant.builtin \"^(NotImplemented|Ellipsis|quit|exit|copyright|credits|license)$\" ))\n\n((identifier) @constant.builtin\n (#match? @constant.builtin \"^__[a-zA-Z0-9_]*__$\" ))\n\n((identifier) @constant\n (#match? @constant \"^[A-Z][A-Z_0-9]*$\" ))\n\n((identifier) @type\n (#match? @type \"^[A-Z].*[a-z]\" ))\n(interpolation) @none\n\n;; Identifier naming conventions\n(identifier) @variable\n\n; Reset highlighting in f-string interpolations\n";
pub const PYTHON_INJECTIONS: &str = "((comment) @injection.content\n (#set! injection.language \"comment\"))\n\n((call\n  function: (attribute\n\t  object: (identifier) @_re)\n  arguments: (argument_list\n    (string\n      (string_content) @injection.content) @_string))\n (#eq? @_re \"re\")\n (#match? @_string \"^r.*\")\n (#set! injection.language \"regex\"))\n";
pub const PYTHON_LOCALS: &str = ";; Forked from https://github.com/helix-editor/helix\n;; Licensed under the Mozilla Public License 2.0\n\n;; Scopes\n\n[\n  (module)\n  (function_definition)\n  (lambda)\n] @local.scope\n\n;; Definitions\n\n; Parameters\n(parameters\n  (identifier) @local.definition)\n(parameters\n  (typed_parameter\n    (identifier) @local.definition))\n(parameters\n  (default_parameter\n    name: (identifier) @local.definition))\n(parameters\n  (typed_default_parameter\n    name: (identifier) @local.definition))\n(parameters\n  (list_splat_pattern ; *args\n    (identifier) @local.definition))\n(parameters\n  (dictionary_splat_pattern ; **kwargs\n    (identifier) @local.definition))\n\n(lambda_parameters\n  (identifier) @local.definition)\n\n; Imports\n(import_statement\n  name: (dotted_name\n    (identifier) @local.definition))\n\n(aliased_import\n  alias: (identifier) @local.definition)\n\n;; References\n\n(identifier) @local.reference\n";

pub const REGEX_HIGHLIGHTS: &str = ";; Forked from https://github.com/tree-sitter/tree-sitter-regex\n;; The MIT License (MIT) Copyright (c) 2014 Max Brunsfeld\n\n[\n  \"(\"\n  \")\"\n  \"(?\"\n  \"(?:\"\n  \"(?<\"\n  \">\"\n  \"[\"\n  \"]\"\n  \"{\"\n  \"}\"\n] @punctuation.bracket\n\n(group_name) @property\n\n[\n  (identity_escape)\n  (control_letter_escape)\n  (character_class_escape)\n  (control_escape)\n  (boundary_assertion)\n  (non_boundary_assertion)\n] @string.escape\n\n[\n  (any_character)\n  (start_assertion)\n  (end_assertion)\n] @punctuation.special\n\n[\n  \"*\"\n  \"+\"\n  \"?\"\n  (lazy)\n  \"|\"\n  \"=\"\n  \"<=\"\n  \"!\"\n  \"<!\"\n] @operator\n\n(count_quantifier\n  [\n    (decimal_digits) @number\n    \",\" @punctuation.delimiter\n  ])\n\n(character_class\n  [\n    \"^\" @operator\n    (class_range \"-\" @operator)\n  ])\n\n(class_character) @constant.character\n\n(pattern_character) @string\n";
pub const REGEX_INJECTIONS: &str = "";
pub const REGEX_LOCALS: &str = "";

pub const RUST_HIGHLIGHTS: &str = "(macro_invocation macro: (identifier) @_ident @exception \"!\" @exception\n (#match? @_ident \"assert\" ))\n(macro_invocation macro: (identifier) @_ident @exception \"!\" @exception\n (#eq? @_ident \"panic\"))\n(empty_type \"!\" @type.builtin)\n\n(macro_invocation \"!\" @function.macro)\n(inner_attribute_item [\"!\" \"#\"] @punctuation.special)\n(attribute_item \"#\" @punctuation.special)\n[\",\" \".\" \":\" \"::\" \";\"] @punctuation.delimiter\n\n(for_lifetimes [\"<\" \">\"] @punctuation.bracket)\n\n(bracketed_type [\"<\" \">\"] @punctuation.bracket)\n(type_parameters [\"<\" \">\"] @punctuation.bracket)\n(type_arguments  [\"<\" \">\"] @punctuation.bracket)\n(closure_parameters \"|\"    @punctuation.bracket)\n[\"(\" \")\" \"[\" \"]\" \"{\" \"}\"]  @punctuation.bracket\n[\n  \"!\"\n  \"!=\"\n  \"%\"\n  \"%=\"\n  \"&\"\n  \"&&\"\n  \"&=\"\n  \"*\"\n  \"*=\"\n  \"+\"\n  \"+=\"\n  \"-\"\n  \"-=\"\n  \"->\"\n  \"..\"\n  \"..=\"\n  \"/\"\n  \"/=\"\n  \"<\"\n  \"<<\"\n  \"<<=\"\n  \"<=\"\n  \"=\"\n  \"==\"\n  \"=>\"\n  \">\"\n  \">=\"\n  \">>\"\n  \">>=\"\n  \"?\"\n  \"@\"\n  \"^\"\n  \"^=\"\n  \"|\"\n  \"|=\"\n  \"||\"\n] @operator\n\n(for_expression\n  \"for\" @repeat)\n\n;;; Operators & Punctuation\n\n\"for\" @keyword\n[\n  \"break\"\n  \"continue\"\n  \"in\"\n  \"loop\"\n  \"while\"\n] @repeat\n\n[\n  \"else\"\n  \"if\"\n] @conditional\n\n(visibility_modifier [(crate) (super) (self)] @namespace)\n\n(scoped_identifier [(crate) (super) (self)] @namespace)\n(scoped_use_list (self) @namespace)\n(use_list (self) @namespace)\n(qualified_type \"as\" @keyword.operator)\n\n(type_cast_expression \"as\" @keyword.operator)\n[\n  \"return\"\n  \"yield\"\n] @keyword.return\n\n\"fn\" @keyword.function\n(lifetime [\"'\" (identifier)] @storageclass.lifetime)\n\n[\n \"const\"\n \"static\"\n] @storageclass\n\n[\n \"ref\"\n (mutable_specifier)\n] @type.qualifier\n\n[\n  \"async\"\n  \"await\"\n] @keyword.coroutine\n\n[\n  \"default\"\n  \"dyn\"\n  \"enum\"\n  \"extern\"\n  \"impl\"\n  \"let\"\n  \"match\"\n  \"move\"\n  \"pub\"\n  \"struct\"\n  \"trait\"\n  \"type\"\n  \"union\"\n  \"unsafe\"\n  \"where\"\n] @keyword\n\n(use_as_clause \"as\" @include)\n\n[\n  \"use\"\n  \"mod\"\n] @include\n(char_literal) @character\n\n\n;;; Keywords\n\n(escape_sequence) @string.escape\n[\n  (raw_string_literal)\n  (string_literal)\n] @string\n(float_literal) @float\n\n(integer_literal) @number\n(boolean_literal) @boolean\n((block_comment) @comment.documentation\n  (#match? @comment.documentation \"^/[*][!]\" ))\n\n((block_comment) @comment.documentation\n  (#match? @comment.documentation \"^/[*][*][^*].*[*]/$\" ))\n((line_comment) @comment.documentation\n  (#match? @comment.documentation \"^//!\" ))\n\n((line_comment) @comment.documentation\n  (#match? @comment.documentation \"^///$\" ))\n((line_comment) @comment.documentation\n  (#match? @comment.documentation \"^///[^/]\" ))\n[\n  (line_comment)\n  (block_comment)\n] @comment @spell\n\n(macro_invocation\n  macro: (scoped_identifier\n           (identifier) @function.macro .))\n\n\n\n;;; Literals\n\n(macro_invocation\n  macro: (identifier) @function.macro)\n(attribute (scoped_identifier (identifier) @function.macro .))\n\n;; Derive macros (assume all arguments are types)\n; (attribute\n;   (identifier) @_name\n;   arguments: (attribute (attribute (identifier) @type))\n;   (#eq? @_name \"derive\"))\n\n;; Function-like macros\n(attribute_item (attribute (identifier) @function.macro))\n(macro_definition \"macro_rules!\" @function.macro)\n\n;; Attribute macros\n(metavariable) @function.macro\n\"$\" @function.macro\n((identifier) @constant.builtin\n (#match? @constant.builtin \"^(Some|None|Ok|Err)$\" ))\n\n;; Macro definitions\n((match_arm\n   pattern: (match_pattern\n     (scoped_identifier\n       name: (identifier) @constant)))\n (#match? @constant \"^[A-Z]\" ))\n\n((match_arm\n   pattern: (match_pattern (identifier) @constant))\n (#match? @constant \"^[A-Z]\" ))\n(call_expression\n  function: (scoped_identifier\n    \"::\"\n    name: (identifier) @constant)\n  (#match? @constant \"^[A-Z]\" ))\n\n; Assume uppercase names in a match arm are constants.\n(use_as_clause alias: (identifier) @type (#match? @type \"^[A-Z]\" ))\n\n;; Correct enum constructors\n(use_list (identifier) @type (#match? @type \"^[A-Z]\" ))\n(use_list (scoped_identifier (identifier) @namespace . (_)))\n(scoped_use_list\n  path: (scoped_identifier\n            (identifier) @namespace))\n(scoped_use_list\n  path: (identifier) @namespace)\n[\n  (crate)\n  (super)\n] @namespace\n\n((scoped_identifier\n    name: (identifier) @constant)\n (#match? @constant \"^[A-Z][A-Z[0-9]_]*$\" ))\n\n((scoped_identifier\n    name: (identifier) @type)\n (#match? @type \"^[A-Z]\" ))\n((scoped_identifier\n  path: (identifier) @type)\n (#match? @type \"^[A-Z]\" ))\n(scoped_type_identifier\n (scoped_identifier\n  name: (identifier) @namespace))\n(scoped_type_identifier\n  path: (identifier) @type\n  (#match? @type \"^[A-Z]\" ))\n(scoped_type_identifier\n  path: (identifier) @namespace)\n(scoped_identifier\n (scoped_identifier\n  name: (identifier) @namespace))\n(scoped_identifier\n  path: (identifier) @namespace)\n(enum_variant\n  name: (identifier) @constant)\n\n; Assume that uppercase names in paths are types\n((field_identifier) @constant\n (#match? @constant \"^[A-Z]\" ))\n\n(generic_function\n  function: (field_expression\n    field: (field_identifier) @function.call))\n\n; Assume other uppercase names are enum constructors\n(generic_function\n  function: (scoped_identifier\n    name: (identifier) @function.call))\n(generic_function\n  function: (identifier) @function.call)\n(call_expression\n  function: (field_expression\n    field: (field_identifier) @function.call))\n\n(call_expression\n  function: (scoped_identifier\n              (identifier) @function.call .))\n(call_expression\n  function: (identifier) @function.call)\n(closure_parameters (_) @parameter)\n\n; Function calls\n(parameter (identifier) @parameter)\n(function_signature_item (identifier) @function)\n\n(function_item (identifier) @function)\n(loop_label [\"'\" (identifier)] @label)\n\n\n; Function definitions\n\n(self) @variable.builtin\n\n(mod_item\n name: (identifier) @namespace)\n\n(shorthand_field_initializer\n  (identifier) @field)\n(field_identifier) @field\n(primitive_type) @type.builtin\n(type_identifier) @type\n((identifier) @constant\n (#match? @constant \"^[A-Z][A-Z[0-9]_]*$\" ))\n\n; Other identifiers\n\n(const_item\n  name: (identifier) @constant)\n; Assume all-caps names are constants\n((identifier) @type\n (#match? @type \"^[A-Z]\" ))\n(identifier) @variable\n";
pub const RUST_INJECTIONS: &str = ";; Forked from https://github.com/helix-editor/helix\n;; Licensed under the Mozilla Public License 2.0\n\n([(line_comment) (block_comment)] @injection.content\n (#set! injection.language \"comment\"))\n\n((macro_invocation\n  (token_tree) @injection.content)\n (#set! injection.language \"rust\")\n (#set! injection.include-children))\n\n((macro_rule\n  (token_tree) @injection.content)\n (#set! injection.language \"rust\")\n (#set! injection.include-children))\n\n(call_expression\n  function: (scoped_identifier\n    path: (identifier) @_regex (#eq? @_regex \"Regex\")\n    name: (identifier) @_new (#eq? @_new \"new\"))\n  arguments: (arguments (raw_string_literal) @injection.content)\n  (#set! injection.language \"regex\"))\n\n(call_expression\n  function: (scoped_identifier\n    path: (scoped_identifier (identifier) @_regex (#eq? @_regex \"Regex\") .)\n    name: (identifier) @_new (#eq? @_new \"new\"))\n  arguments: (arguments (raw_string_literal) @injection.content)\n  (#set! injection.language \"regex\"))\n\n; Highlight SQL in `sqlx::query!()`\n(macro_invocation\n  macro: (scoped_identifier\n    path: (identifier) @_sqlx (#eq? @_sqlx \"sqlx\")\n    name: (identifier) @_query (#eq? @_query \"query\"))\n  (token_tree\n    ; Only the first argument is SQL\n    .\n    [(string_literal) (raw_string_literal)] @injection.content\n  )\n  (#set! injection.language \"sql\"))\n\n; Highlight SQL in `sqlx::query_as!()`\n(macro_invocation\n  macro: (scoped_identifier\n    path: (identifier) @_sqlx (#eq? @_sqlx \"sqlx\")\n    name: (identifier) @_query_as (#eq? @_query_as \"query_as\"))\n  (token_tree\n    ; Only the second argument is SQL\n    .\n    ; Allow anything as the first argument in case the user has lower case type\n    ; names for some reason\n    (_)\n    [(string_literal) (raw_string_literal)] @injection.content\n  )\n  (#set! injection.language \"sql\"))\n\n; Highlight SQL in `sqlx::query_unchecked!()`\n(macro_invocation\n  macro: (scoped_identifier\n    path: (identifier) @_sqlx (#eq? @_sqlx \"sqlx\")\n    name: (identifier) @_query_as (#eq? @_query_as \"query_unchecked\"))\n  (token_tree\n    ; Only the first argument is SQL\n    .\n    [(string_literal) (raw_string_literal)] @injection.content\n  )\n  (#set! injection.language \"sql\"))\n\n; Highlight SQL in `sqlx::query_as_unchecked!()`\n(macro_invocation\n  macro: (scoped_identifier\n    path: (identifier) @_sqlx (#eq? @_sqlx \"sqlx\")\n    name: (identifier) @_query_as (#eq? @_query_as \"query_as_unchecked\"))\n  (token_tree\n    ; Only the second argument is SQL\n    .\n    ; Allow anything as the first argument in case the user has lower case type\n    ; names for some reason\n    (_)\n    [(string_literal) (raw_string_literal)] @injection.content\n  )\n  (#set! injection.language \"sql\"))\n";
pub const RUST_LOCALS: &str = ";; Forked from https://github.com/helix-editor/helix\n;; Licensed under the Mozilla Public License 2.0\n\n; Scopes\n\n[\n  (function_item)\n  (closure_expression)\n  (block)\n] @local.scope\n\n; Definitions\n\n(parameter\n  (identifier) @local.definition)\n\n(closure_parameters (identifier) @local.definition)\n\n; References\n(identifier) @local.reference\n";

pub const TSX_HIGHLIGHTS: &str = "(jsx_text) @none\n\n(jsx_self_closing_element ((nested_identifier (identifier) @tag (identifier) @constructor)))\n\n(jsx_self_closing_element ((identifier) @constructor\n (#match? @constructor \"^[A-Z]\" )))\n\n; Handle the dot operator effectively - <My.Component />\n(jsx_closing_element ((nested_identifier (identifier) @tag (identifier) @constructor)))\n\n(jsx_closing_element ((identifier) @constructor\n (#match? @constructor \"^[A-Z]\" )))\n\n; Handle the dot operator effectively - </My.Component>\n(jsx_opening_element ((nested_identifier (identifier) @tag (identifier) @constructor)))\n\n(jsx_opening_element ((identifier) @constructor\n (#match? @constructor \"^[A-Z]\" )))\n\n; Handle the dot operator effectively - <My.Component>\n(jsx_self_closing_element\n  name: (identifier) @tag)\n\n(jsx_closing_element\n  name: (identifier) @tag)\n\n(jsx_opening_element\n  name: (identifier) @tag)\n\n(jsx_attribute (property_identifier) @tag.attribute)\n\n(jsx_fragment [\">\" \"<\" \"/\"] @tag.delimiter)\n(jsx_self_closing_element [\"/\" \">\" \"<\"] @tag.delimiter)\n(jsx_element\n  close_tag: (jsx_closing_element [\"<\" \"/\" \">\"] @tag.delimiter))\n(jsx_element\n  open_tag: (jsx_opening_element [\"<\" \">\"] @tag.delimiter))\n(property_signature\n  name: (property_identifier) @method\n  type: (type_annotation\n          [\n            (union_type (parenthesized_type (function_type)))\n            (function_type)\n          ]))\n\n\n;; Forked from https://github.com/nvim-treesitter/nvim-treesitter/blob/master/queries/jsx/highlights.scm\n;; Licensed under the Apache License 2.0\n\n(method_signature name: (_) @method)\n\n;; property signatures\n(ambient_declaration\n  (function_signature\n    name: (identifier) @function))\n\n;; method signatures\n(arrow_function\n  parameter: (identifier) @parameter)\n\n;; function signatures\n(required_parameter\n  (array_pattern\n    (identifier) @parameter))\n\n;; a => null\n(required_parameter\n  (object_pattern\n    (pair_pattern\n      value: (identifier) @parameter)))\n\n;; ([ a ]) => null\n(required_parameter\n  (object_pattern\n    (shorthand_property_identifier_pattern) @parameter))\n\n;; ({ a: b }) => null\n(required_parameter\n  (rest_pattern\n    (identifier) @parameter))\n\n;; ({ a }) => null\n(optional_parameter (identifier) @parameter)\n\n(required_parameter (identifier) @parameter)\n(undefined) @variable.builtin\n\n;;; Parameters\n(conditional_type [\"?\" \":\"] @conditional.ternary)\n\n; Variables\n\n(template_type [\"${\" \"}\"] @punctuation.special)\n\n(optional_parameter \"?\" @punctuation.special)\n\n(property_signature \"?\" @punctuation.special)\n(method_signature \"?\" @punctuation.special)\n\"?.\" @punctuation.delimiter\n\n(opting_type_annotation\n  \"?:\" @punctuation.delimiter)\n\n(index_signature\n  \":\" @punctuation.delimiter)\n\n(type_annotation\n  \":\" @punctuation.delimiter)\n\n(intersection_type\n  \"&\" @punctuation.delimiter)\n\n(union_type\n  \"|\" @punctuation.delimiter)\n\n(type_parameters\n  [\"<\" \">\"] @punctuation.bracket)\n\n(type_arguments\n  [\"<\" \">\"] @punctuation.bracket)\n\n(non_null_expression \"!\" @operator)\n\n;; punctuation\n\n(template_literal_type) @string\n\n(import_statement \"type\"\n  (import_clause\n    (named_imports\n      ((import_specifier\n          name: (identifier) @type)))))\n\n(predefined_type) @type.builtin\n\n(type_identifier) @type\n[\n  \"abstract\"\n  \"private\"\n  \"protected\"\n  \"public\"\n  \"readonly\"\n] @type.qualifier\n\n; types\n\n(as_expression \"as\" @keyword)\n\n[\n  \"declare\"\n  \"enum\"\n  \"export\"\n  \"implements\"\n  \"interface\"\n  \"keyof\"\n  \"type\"\n  \"namespace\"\n  \"override\"\n  \"satisfies\"\n  \"module\"\n  \"infer\"\n] @keyword\n\n(switch_default\n  \"default\" @conditional)\n\n(export_statement\n  \"default\" @keyword)\n[\n  \"throw\"\n  \"try\"\n  \"catch\"\n  \"finally\"\n] @exception\n\n[\n  \"new\"\n  \"delete\"\n] @keyword.operator\n\n[\n  \"function\"\n] @keyword.function\n\n[\n  \"return\"\n  \"yield\"\n] @keyword.return\n\n[\n  \"async\"\n  \"await\"\n] @keyword.coroutine\n\n[\n  \"break\"\n  \"class\"\n  \"const\"\n  \"debugger\"\n  \"export\"\n  \"extends\"\n  \"get\"\n  \"in\"\n  \"instanceof\"\n  \"let\"\n  \"set\"\n  \"static\"\n  \"target\"\n  \"typeof\"\n  \"var\"\n  \"with\"\n] @keyword\n\n[\n  \"for\"\n  \"of\"\n  \"do\"\n  \"while\"\n  \"continue\"\n] @repeat\n\n(namespace_import \"as\" @include)\n\n(namespace_export \"as\" @include)\n(import_specifier \"as\" @include)\n(export_specifier \"as\" @include)\n[\n  \"import\"\n  \"from\"\n] @include\n\n[\n  \"if\"\n  \"else\"\n  \"switch\"\n  \"case\"\n] @conditional\n\n((template_substitution [\"${\" \"}\"] @punctuation.special) @none)\n\n; Keywords\n;----------\n\n[\n  \"(\"\n  \")\"\n  \"[\"\n  \"]\"\n  \"{\"\n  \"}\"\n] @punctuation.bracket\n\n(unary_expression [\"delete\" \"void\" \"typeof\"] @keyword.operator)\n\n(unary_expression [\"!\" \"~\" \"-\" \"+\"] @operator)\n(ternary_expression [\"?\" \":\"] @conditional.ternary)\n(binary_expression \"/\" @operator)\n[\n  \"--\"\n  \"-\"\n  \"-=\"\n  \"&&\"\n  \"+\"\n  \"++\"\n  \"+=\"\n  \"&=\"\n  \"/=\"\n  \"**=\"\n  \"<<=\"\n  \"<\"\n  \"<=\"\n  \"<<\"\n  \"=\"\n  \"==\"\n  \"===\"\n  \"!=\"\n  \"!==\"\n  \"=>\"\n  \">\"\n  \">=\"\n  \">>\"\n  \"||\"\n  \"%\"\n  \"%=\"\n  \"*\"\n  \"**\"\n  \">>>\"\n  \"&\"\n  \"|\"\n  \"^\"\n  \"??\"\n  \"*=\"\n  \">>=\"\n  \">>>=\"\n  \"^=\"\n  \"|=\"\n  \"&&=\"\n  \"||=\"\n  \"??=\"\n] @operator\n\n(switch_case \":\" @punctuation.delimiter)\n\n(pair_pattern \":\" @punctuation.delimiter)\n(pair \":\" @punctuation.delimiter)\n\",\" @punctuation.delimiter\n\n\".\" @punctuation.delimiter\n\";\" @punctuation.delimiter\n\"...\" @punctuation.special\n\n((identifier) @number\n  (#match? @number \"^(NaN|Infinity)$\" ))\n\n; Punctuation\n;------------\n\n(number) @number\n(regex \"/\" @punctuation.bracket) ; Regex delimiters\n\n(regex_pattern) @string.regex\n(escape_sequence) @string.escape\n(template_string) @string\n(string) @string @spell\n((string_fragment) @preproc\n (#eq? @preproc \"use strict\"))\n\n(hash_bang_line) @preproc\n\n((comment) @comment.documentation\n  (#match? @comment.documentation \"^/[*][*][^*].*[*]/$\" ))\n\n(comment) @comment @spell\n\n[\n  (null)\n  (undefined)\n] @constant.builtin\n\n[\n  (true)\n  (false)\n] @boolean\n\n[\n  (this)\n  (super)\n] @variable.builtin\n\n(namespace_import\n  (identifier) @namespace)\n\n; Literals\n;---------\n\n(new_expression\n  constructor: (identifier) @constructor)\n\n; Variables\n;----------\n(call_expression\n  function: (member_expression\n    property: [(property_identifier) (private_property_identifier)] @method.call))\n\n; Constructor\n;------------\n\n(call_expression\n  function: (identifier) @function.call)\n\n(assignment_expression\n  left: (identifier) @function\n  right: (function))\n\n; Function and method calls\n;--------------------------\n\n(assignment_expression\n  left: (identifier) @function\n  right: (arrow_function))\n(variable_declarator\n  name: (identifier) @function\n  value: (function))\n\n(variable_declarator\n  name: (identifier) @function\n  value: (arrow_function))\n(assignment_expression\n  left: (member_expression\n    property: (property_identifier) @method)\n  right: (function))\n\n(assignment_expression\n  left: (member_expression\n    property: (property_identifier) @method)\n  right: (arrow_function))\n(pair\n  key: (property_identifier) @method\n  value: (arrow_function))\n\n(pair\n  key: (property_identifier) @method\n  value: (function))\n(method_definition\n  name: (property_identifier) @constructor\n  (#eq? @constructor \"constructor\"))\n\n(method_definition\n  name: [(property_identifier) (private_property_identifier)] @method)\n(generator_function_declaration\n  name: (identifier) @function)\n(generator_function\n  name: (identifier) @function)\n(function_declaration\n  name: (identifier) @function)\n(function\n  name: (identifier) @function)\n((identifier) @function.builtin\n (#match? @function.builtin \"^(eval|isFinite|isNaN|parseFloat|parseInt|decodeURI|decodeURIComponent|encodeURI|encodeURIComponent|require)$\" ))\n\n; Function and method definitions\n;--------------------------------\n\n((identifier) @namespace.builtin\n (#eq? @namespace.builtin \"Intl\"))\n\n((identifier) @type.builtin\n (#match? @type.builtin \"^(Object|Function|Boolean|Symbol|Number|Math|Date|String|RegExp|Map|Set|WeakMap|WeakSet|Promise|Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array|ArrayBuffer|DataView|Error|EvalError|InternalError|RangeError|ReferenceError|SyntaxError|TypeError|URIError)$\" ))\n\n((identifier) @variable.builtin\n (#match? @variable.builtin \"^(arguments|module|console|window|document)$\" ))\n\n((shorthand_property_identifier) @constant\n (#match? @constant \"^_*[A-Z][A-Z[0-9]_]*$\" ))\n\n((identifier) @constant\n (#match? @constant \"^_*[A-Z][A-Z[0-9]_]*$\" ))\n\n((identifier) @type\n (#match? @type \"^[A-Z]\" ))\n\n(variable_declarator\n  name: (object_pattern\n    (shorthand_property_identifier_pattern))) @variable\n\n; Special identifiers\n;--------------------\n\n(private_property_identifier) @property\n\n(shorthand_property_identifier) @property\n(property_identifier) @property\n(identifier) @variable\n\n; Properties\n;-----------\n\n";
pub const TSX_INJECTIONS: &str = "\n;; Forked from https://github.com/nvim-treesitter/nvim-treesitter/blob/master/queries/ecma/injections.scm\n;; Licensed under the Apache License 2.0\n\n(((comment) @_jsdoc_comment\n  (#lua-match? @_jsdoc_comment \"^/[*][*][^*].*[*]/$\")) @injection.content\n  (#set! injection.language \"jsdoc\"))\n\n((comment) @injection.content\n (#set! injection.language \"comment\"))\n\n; html(`...`), html`...`, sql(...) etc\n(call_expression\n function: ((identifier) @injection.language)\n arguments: [\n             (arguments\n              (template_string) @injection.content)\n             (template_string) @injection.content\n            ]\n     (#offset! @injection.content 0 1 0 -1)\n     (#not-eq? @injection.language \"svg\"))\n\n; svg`...` or svg(`...`), which uses the html parser, so is not included in the previous query\n(call_expression\n function: ((identifier) @_name (#eq? @_name \"svg\"))\n arguments: [\n             (arguments\n              (template_string) @injection.content)\n             (template_string) @injection.content\n            ]\n     (#offset! @injection.content 0 1 0 -1)\n     (#set! injection.language \"html\"))\n\n\n(call_expression\n function: ((identifier) @_name\n   (#eq? @_name \"gql\"))\n arguments: ((template_string) @injection.content\n   (#offset! @injection.content 0 1 0 -1)\n   (#set! injection.language \"graphql\")))\n\n(call_expression\n function: ((identifier) @_name\n   (#eq? @_name \"hbs\"))\n arguments: ((template_string) @injection.content\n   (#offset! @injection.content 0 1 0 -1)\n   (#set! injection.language \"glimmer\")))\n\n(\n (glimmer_template) @injection.content\n (#set! injection.language \"glimmer\"))\n\n; styled.div`<css>`\n(call_expression\n function: (member_expression\n   object: (identifier) @_name\n     (#eq? @_name \"styled\"))\n arguments: ((template_string) @injection.content\n   (#offset! @injection.content 0 1 0 -1)\n   (#set! injection.language \"css\")))\n\n; styled(Component)`<css>`\n(call_expression\n function: (call_expression\n   function: (identifier) @_name\n     (#eq? @_name \"styled\"))\n arguments: ((template_string) @injection.content\n   (#offset! @injection.content 0 1 0 -1)\n   (#set! injection.language \"css\")))\n\n; styled.div.attrs({ prop: \"foo\" })`<css>`\n(call_expression\n function: (call_expression\n   function: (member_expression\n    object: (member_expression\n      object: (identifier) @_name\n        (#eq? @_name \"styled\"))))\n arguments: ((template_string) @injection.content\n   (#offset! @injection.content 0 1 0 -1)\n   (#set! injection.language \"css\")))\n\n\n; styled(Component).attrs({ prop: \"foo\" })`<css>`\n(call_expression\n function: (call_expression\n   function: (member_expression\n    object: (call_expression\n      function: (identifier) @_name\n        (#eq? @_name \"styled\"))))\n arguments: ((template_string) @injection.content\n   (#offset! @injection.content 0 1 0 -1)\n   (#set! injection.language \"css\")))\n\n((regex_pattern) @injection.content (#set! injection.language \"regex\"))\n\n; ((comment) @_gql_comment\n;   (#eq? @_gql_comment \"/* GraphQL */\")\n;   (template_string) @graphql)\n\n((template_string) @injection.content\n  (#lua-match? @injection.content \"^`#graphql\")\n  (#offset! @injection.content 0 1 0 -1)\n  (#set! injection.language \"graphql\"))\n\n; el.innerHTML = `<html>`\n(assignment_expression\n  left: (member_expression\n          property: (property_identifier) @_prop\n           (#any-of? @_prop \"innerHTML\" \"outerHTML\"))\n  right: (template_string) @injection.content\n    (#offset! @injection.content 0 1 0 -1)\n    (#set! injection.language \"html\"))\n\n; el.innerHTML = '<html>'\n(assignment_expression\n   left: (member_expression\n           property: (property_identifier) @_prop\n            (#any-of? @_prop \"innerHTML\" \"outerHTML\"))\n   right: (string) @injection.content\n            (#offset! @injection.content 0 1 0 -1)\n            (#set! injection.language \"html\"))\n\n\n;; Forked from https://github.com/nvim-treesitter/nvim-treesitter/blob/master/queries/jsx/injections.scm\n;; Licensed under the Apache License 2.0\n\n; Styled Jsx <style jsx>\n(jsx_element\n  (jsx_opening_element\n    (identifier) @_name (#eq? @_name \"style\")\n    (jsx_attribute) @_attr (#eq? @_attr \"jsx\"))\n  (jsx_expression (template_string) @injection.content\n    (#offset! @injection.content 0 1 0 -1)\n    (#set! injection.language)))\n\n";
pub const TSX_LOCALS: &str = "\n\n;; Forked from https://github.com/nvim-treesitter/nvim-treesitter/blob/master/queries/ecma/locals.scm\n;; Licensed under the Apache License 2.0\n\n; Scopes\n;-------\n\n(statement_block) @local.scope\n(function) @local.scope\n(arrow_function) @local.scope\n(function_declaration) @local.scope\n(method_definition) @local.scope\n(for_statement) @local.scope\n(for_in_statement) @local.scope\n(catch_clause) @local.scope\n\n; Definitions\n;------------\n\n(variable_declarator\n  name: (identifier) @local.definition)\n\n(import_specifier\n  (identifier) @local.definition)\n\n(namespace_import\n  (identifier) @local.definition)\n\n(function_declaration\n  ((identifier) @local.definition)\n   (#set! definition.var.scope parent))\n\n(method_definition\n  ((property_identifier) @local.definition)\n   (#set! definition.var.scope parent))\n\n; References\n;------------\n\n(identifier) @local.reference\n(shorthand_property_identifier) @local.reference\n\n(required_parameter (identifier) @local.definition)\n(optional_parameter (identifier) @local.definition)\n\n; x => x\n(arrow_function\n  parameter: (identifier) @local.definition)\n\n;; ({ a }) => null\n(required_parameter\n  (object_pattern\n    (shorthand_property_identifier_pattern) @local.definition))\n\n;; ({ a: b }) => null\n(required_parameter\n  (object_pattern\n    (pair_pattern\n      value: (identifier) @local.definition)))\n\n;; ([ a ]) => null\n(required_parameter\n  (array_pattern\n    (identifier) @local.definition))\n\n(required_parameter\n  (rest_pattern\n    (identifier) @local.definition))\n\n";

pub const TYPESCRIPT_HIGHLIGHTS: &str = "(property_signature\n  name: (property_identifier) @method\n  type: (type_annotation\n          [\n            (union_type (parenthesized_type (function_type)))\n            (function_type)\n          ]))\n(method_signature name: (_) @method)\n\n;; property signatures\n(ambient_declaration\n  (function_signature\n    name: (identifier) @function))\n\n;; method signatures\n(arrow_function\n  parameter: (identifier) @parameter)\n\n;; function signatures\n(required_parameter\n  (array_pattern\n    (identifier) @parameter))\n\n;; a => null\n(required_parameter\n  (object_pattern\n    (pair_pattern\n      value: (identifier) @parameter)))\n\n;; ([ a ]) => null\n(required_parameter\n  (object_pattern\n    (shorthand_property_identifier_pattern) @parameter))\n\n;; ({ a: b }) => null\n(required_parameter\n  (rest_pattern\n    (identifier) @parameter))\n\n;; ({ a }) => null\n(optional_parameter (identifier) @parameter)\n\n(required_parameter (identifier) @parameter)\n(undefined) @variable.builtin\n\n;;; Parameters\n(conditional_type [\"?\" \":\"] @conditional.ternary)\n\n; Variables\n\n(template_type [\"${\" \"}\"] @punctuation.special)\n\n(optional_parameter \"?\" @punctuation.special)\n\n(property_signature \"?\" @punctuation.special)\n(method_signature \"?\" @punctuation.special)\n\"?.\" @punctuation.delimiter\n\n(opting_type_annotation\n  \"?:\" @punctuation.delimiter)\n\n(index_signature\n  \":\" @punctuation.delimiter)\n\n(type_annotation\n  \":\" @punctuation.delimiter)\n\n(intersection_type\n  \"&\" @punctuation.delimiter)\n\n(union_type\n  \"|\" @punctuation.delimiter)\n\n(type_parameters\n  [\"<\" \">\"] @punctuation.bracket)\n\n(type_arguments\n  [\"<\" \">\"] @punctuation.bracket)\n\n(non_null_expression \"!\" @operator)\n\n;; punctuation\n\n(template_literal_type) @string\n\n(import_statement \"type\"\n  (import_clause\n    (named_imports\n      ((import_specifier\n          name: (identifier) @type)))))\n\n(predefined_type) @type.builtin\n\n(type_identifier) @type\n[\n  \"abstract\"\n  \"private\"\n  \"protected\"\n  \"public\"\n  \"readonly\"\n] @type.qualifier\n\n; types\n\n(as_expression \"as\" @keyword)\n\n[\n  \"declare\"\n  \"enum\"\n  \"export\"\n  \"implements\"\n  \"interface\"\n  \"keyof\"\n  \"type\"\n  \"namespace\"\n  \"override\"\n  \"satisfies\"\n  \"module\"\n  \"infer\"\n] @keyword\n\n(switch_default\n  \"default\" @conditional)\n\n(export_statement\n  \"default\" @keyword)\n[\n  \"throw\"\n  \"try\"\n  \"catch\"\n  \"finally\"\n] @exception\n\n[\n  \"new\"\n  \"delete\"\n] @keyword.operator\n\n[\n  \"function\"\n] @keyword.function\n\n[\n  \"return\"\n  \"yield\"\n] @keyword.return\n\n[\n  \"async\"\n  \"await\"\n] @keyword.coroutine\n\n[\n  \"break\"\n  \"class\"\n  \"const\"\n  \"debugger\"\n  \"export\"\n  \"extends\"\n  \"get\"\n  \"in\"\n  \"instanceof\"\n  \"let\"\n  \"set\"\n  \"static\"\n  \"target\"\n  \"typeof\"\n  \"var\"\n  \"with\"\n] @keyword\n\n[\n  \"for\"\n  \"of\"\n  \"do\"\n  \"while\"\n  \"continue\"\n] @repeat\n\n(namespace_import \"as\" @include)\n\n(namespace_export \"as\" @include)\n(import_specifier \"as\" @include)\n(export_specifier \"as\" @include)\n[\n  \"import\"\n  \"from\"\n] @include\n\n[\n  \"if\"\n  \"else\"\n  \"switch\"\n  \"case\"\n] @conditional\n\n((template_substitution [\"${\" \"}\"] @punctuation.special) @none)\n\n; Keywords\n;----------\n\n[\n  \"(\"\n  \")\"\n  \"[\"\n  \"]\"\n  \"{\"\n  \"}\"\n] @punctuation.bracket\n\n(unary_expression [\"delete\" \"void\" \"typeof\"] @keyword.operator)\n\n(unary_expression [\"!\" \"~\" \"-\" \"+\"] @operator)\n(ternary_expression [\"?\" \":\"] @conditional.ternary)\n(binary_expression \"/\" @operator)\n[\n  \"--\"\n  \"-\"\n  \"-=\"\n  \"&&\"\n  \"+\"\n  \"++\"\n  \"+=\"\n  \"&=\"\n  \"/=\"\n  \"**=\"\n  \"<<=\"\n  \"<\"\n  \"<=\"\n  \"<<\"\n  \"=\"\n  \"==\"\n  \"===\"\n  \"!=\"\n  \"!==\"\n  \"=>\"\n  \">\"\n  \">=\"\n  \">>\"\n  \"||\"\n  \"%\"\n  \"%=\"\n  \"*\"\n  \"**\"\n  \">>>\"\n  \"&\"\n  \"|\"\n  \"^\"\n  \"??\"\n  \"*=\"\n  \">>=\"\n  \">>>=\"\n  \"^=\"\n  \"|=\"\n  \"&&=\"\n  \"||=\"\n  \"??=\"\n] @operator\n\n(switch_case \":\" @punctuation.delimiter)\n\n(pair_pattern \":\" @punctuation.delimiter)\n(pair \":\" @punctuation.delimiter)\n\",\" @punctuation.delimiter\n\n\".\" @punctuation.delimiter\n\";\" @punctuation.delimiter\n\"...\" @punctuation.special\n\n((identifier) @number\n  (#match? @number \"^(NaN|Infinity)$\" ))\n\n; Punctuation\n;------------\n\n(number) @number\n(regex \"/\" @punctuation.bracket) ; Regex delimiters\n\n(regex_pattern) @string.regex\n(escape_sequence) @string.escape\n(template_string) @string\n(string) @string @spell\n((string_fragment) @preproc\n (#eq? @preproc \"use strict\"))\n\n(hash_bang_line) @preproc\n\n((comment) @comment.documentation\n  (#match? @comment.documentation \"^/[*][*][^*].*[*]/$\" ))\n\n(comment) @comment @spell\n\n[\n  (null)\n  (undefined)\n] @constant.builtin\n\n[\n  (true)\n  (false)\n] @boolean\n\n[\n  (this)\n  (super)\n] @variable.builtin\n\n(namespace_import\n  (identifier) @namespace)\n\n; Literals\n;---------\n\n(new_expression\n  constructor: (identifier) @constructor)\n\n; Variables\n;----------\n(call_expression\n  function: (member_expression\n    property: [(property_identifier) (private_property_identifier)] @method.call))\n\n; Constructor\n;------------\n\n(call_expression\n  function: (identifier) @function.call)\n\n(assignment_expression\n  left: (identifier) @function\n  right: (function))\n\n; Function and method calls\n;--------------------------\n\n(assignment_expression\n  left: (identifier) @function\n  right: (arrow_function))\n(variable_declarator\n  name: (identifier) @function\n  value: (function))\n\n(variable_declarator\n  name: (identifier) @function\n  value: (arrow_function))\n(assignment_expression\n  left: (member_expression\n    property: (property_identifier) @method)\n  right: (function))\n\n(assignment_expression\n  left: (member_expression\n    property: (property_identifier) @method)\n  right: (arrow_function))\n(pair\n  key: (property_identifier) @method\n  value: (arrow_function))\n\n(pair\n  key: (property_identifier) @method\n  value: (function))\n(method_definition\n  name: (property_identifier) @constructor\n  (#eq? @constructor \"constructor\"))\n\n(method_definition\n  name: [(property_identifier) (private_property_identifier)] @method)\n(generator_function_declaration\n  name: (identifier) @function)\n(generator_function\n  name: (identifier) @function)\n(function_declaration\n  name: (identifier) @function)\n(function\n  name: (identifier) @function)\n((identifier) @function.builtin\n (#match? @function.builtin \"^(eval|isFinite|isNaN|parseFloat|parseInt|decodeURI|decodeURIComponent|encodeURI|encodeURIComponent|require)$\" ))\n\n; Function and method definitions\n;--------------------------------\n\n((identifier) @namespace.builtin\n (#eq? @namespace.builtin \"Intl\"))\n\n((identifier) @type.builtin\n (#match? @type.builtin \"^(Object|Function|Boolean|Symbol|Number|Math|Date|String|RegExp|Map|Set|WeakMap|WeakSet|Promise|Array|Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array|ArrayBuffer|DataView|Error|EvalError|InternalError|RangeError|ReferenceError|SyntaxError|TypeError|URIError)$\" ))\n\n((identifier) @variable.builtin\n (#match? @variable.builtin \"^(arguments|module|console|window|document)$\" ))\n\n((shorthand_property_identifier) @constant\n (#match? @constant \"^_*[A-Z][A-Z[0-9]_]*$\" ))\n\n((identifier) @constant\n (#match? @constant \"^_*[A-Z][A-Z[0-9]_]*$\" ))\n\n((identifier) @type\n (#match? @type \"^[A-Z]\" ))\n\n(variable_declarator\n  name: (object_pattern\n    (shorthand_property_identifier_pattern))) @variable\n\n; Special identifiers\n;--------------------\n\n(private_property_identifier) @property\n\n(shorthand_property_identifier) @property\n(property_identifier) @property\n(identifier) @variable\n\n; Properties\n;-----------\n\n";
pub const TYPESCRIPT_INJECTIONS: &str = "\n;; Forked from https://github.com/nvim-treesitter/nvim-treesitter/blob/master/queries/ecma/injections.scm\n;; Licensed under the Apache License 2.0\n\n(((comment) @_jsdoc_comment\n  (#lua-match? @_jsdoc_comment \"^/[*][*][^*].*[*]/$\")) @injection.content\n  (#set! injection.language \"jsdoc\"))\n\n((comment) @injection.content\n (#set! injection.language \"comment\"))\n\n; html(`...`), html`...`, sql(...) etc\n(call_expression\n function: ((identifier) @injection.language)\n arguments: [\n             (arguments\n              (template_string) @injection.content)\n             (template_string) @injection.content\n            ]\n     (#offset! @injection.content 0 1 0 -1)\n     (#not-eq? @injection.language \"svg\"))\n\n; svg`...` or svg(`...`), which uses the html parser, so is not included in the previous query\n(call_expression\n function: ((identifier) @_name (#eq? @_name \"svg\"))\n arguments: [\n             (arguments\n              (template_string) @injection.content)\n             (template_string) @injection.content\n            ]\n     (#offset! @injection.content 0 1 0 -1)\n     (#set! injection.language \"html\"))\n\n\n(call_expression\n function: ((identifier) @_name\n   (#eq? @_name \"gql\"))\n arguments: ((template_string) @injection.content\n   (#offset! @injection.content 0 1 0 -1)\n   (#set! injection.language \"graphql\")))\n\n(call_expression\n function: ((identifier) @_name\n   (#eq? @_name \"hbs\"))\n arguments: ((template_string) @injection.content\n   (#offset! @injection.content 0 1 0 -1)\n   (#set! injection.language \"glimmer\")))\n\n(\n (glimmer_template) @injection.content\n (#set! injection.language \"glimmer\"))\n\n; styled.div`<css>`\n(call_expression\n function: (member_expression\n   object: (identifier) @_name\n     (#eq? @_name \"styled\"))\n arguments: ((template_string) @injection.content\n   (#offset! @injection.content 0 1 0 -1)\n   (#set! injection.language \"css\")))\n\n; styled(Component)`<css>`\n(call_expression\n function: (call_expression\n   function: (identifier) @_name\n     (#eq? @_name \"styled\"))\n arguments: ((template_string) @injection.content\n   (#offset! @injection.content 0 1 0 -1)\n   (#set! injection.language \"css\")))\n\n; styled.div.attrs({ prop: \"foo\" })`<css>`\n(call_expression\n function: (call_expression\n   function: (member_expression\n    object: (member_expression\n      object: (identifier) @_name\n        (#eq? @_name \"styled\"))))\n arguments: ((template_string) @injection.content\n   (#offset! @injection.content 0 1 0 -1)\n   (#set! injection.language \"css\")))\n\n\n; styled(Component).attrs({ prop: \"foo\" })`<css>`\n(call_expression\n function: (call_expression\n   function: (member_expression\n    object: (call_expression\n      function: (identifier) @_name\n        (#eq? @_name \"styled\"))))\n arguments: ((template_string) @injection.content\n   (#offset! @injection.content 0 1 0 -1)\n   (#set! injection.language \"css\")))\n\n((regex_pattern) @injection.content (#set! injection.language \"regex\"))\n\n; ((comment) @_gql_comment\n;   (#eq? @_gql_comment \"/* GraphQL */\")\n;   (template_string) @graphql)\n\n((template_string) @injection.content\n  (#lua-match? @injection.content \"^`#graphql\")\n  (#offset! @injection.content 0 1 0 -1)\n  (#set! injection.language \"graphql\"))\n\n; el.innerHTML = `<html>`\n(assignment_expression\n  left: (member_expression\n          property: (property_identifier) @_prop\n           (#any-of? @_prop \"innerHTML\" \"outerHTML\"))\n  right: (template_string) @injection.content\n    (#offset! @injection.content 0 1 0 -1)\n    (#set! injection.language \"html\"))\n\n; el.innerHTML = '<html>'\n(assignment_expression\n   left: (member_expression\n           property: (property_identifier) @_prop\n            (#any-of? @_prop \"innerHTML\" \"outerHTML\"))\n   right: (string) @injection.content\n            (#offset! @injection.content 0 1 0 -1)\n            (#set! injection.language \"html\"))\n\n";
pub const TYPESCRIPT_LOCALS: &str = "\n;; Forked from https://github.com/nvim-treesitter/nvim-treesitter/blob/master/queries/ecma/locals.scm\n;; Licensed under the Apache License 2.0\n\n; Scopes\n;-------\n\n(statement_block) @local.scope\n(function) @local.scope\n(arrow_function) @local.scope\n(function_declaration) @local.scope\n(method_definition) @local.scope\n(for_statement) @local.scope\n(for_in_statement) @local.scope\n(catch_clause) @local.scope\n\n; Definitions\n;------------\n\n(variable_declarator\n  name: (identifier) @local.definition)\n\n(import_specifier\n  (identifier) @local.definition)\n\n(namespace_import\n  (identifier) @local.definition)\n\n(function_declaration\n  ((identifier) @local.definition)\n   (#set! definition.var.scope parent))\n\n(method_definition\n  ((property_identifier) @local.definition)\n   (#set! definition.var.scope parent))\n\n; References\n;------------\n\n(identifier) @local.reference\n(shorthand_property_identifier) @local.reference\n\n(required_parameter (identifier) @local.definition)\n(optional_parameter (identifier) @local.definition)\n\n; x => x\n(arrow_function\n  parameter: (identifier) @local.definition)\n\n;; ({ a }) => null\n(required_parameter\n  (object_pattern\n    (shorthand_property_identifier_pattern) @local.definition))\n\n;; ({ a: b }) => null\n(required_parameter\n  (object_pattern\n    (pair_pattern\n      value: (identifier) @local.definition)))\n\n;; ([ a ]) => null\n(required_parameter\n  (array_pattern\n    (identifier) @local.definition))\n\n(required_parameter\n  (rest_pattern\n    (identifier) @local.definition))\n";
